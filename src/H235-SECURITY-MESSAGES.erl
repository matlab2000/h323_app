%% Generated by the Erlang ASN.1 PER-compiler version, utilizing bit-syntax:3.0
%% Purpose: encoder and decoder to the types in mod H235-SECURITY-MESSAGES

-module('H235-SECURITY-MESSAGES').
-compile(nowarn_unused_vars).
-include("H235-SECURITY-MESSAGES.hrl").
-asn1_info([{vsn,'3.0'},
            {module,'H235-SECURITY-MESSAGES'},
            {options,[{i,"D:/GK_LINUX/test/erlang"},
 warnings,per,errors,
 {cwd,"D:/GK_LINUX/test/erlang"},
 {outdir,"D:/GK_LINUX/test/erlang"},
 {i,"."},
 {i,"d:/GK_LINUX/test/erlang"}]}]).

-export([encoding_rule/0,bit_string_format/0,         legacy_erlang_types/0]).
-export([
'enc_ChallengeString'/1,
'enc_TimeStamp'/1,
'enc_RandomVal'/1,
'enc_Password'/1,
'enc_Identifier'/1,
'enc_KeyMaterial'/1,
'enc_NonStandardParameter'/1,
'enc_DHset'/1,
'enc_ECpoint'/1,
'enc_ECKASDH'/1,
'enc_ECGDSASignature'/1,
'enc_TypedCertificate'/1,
'enc_AuthenticationBES'/1,
'enc_AuthenticationMechanism'/1,
'enc_ClearToken'/1,
'enc_IV8'/1,
'enc_IV16'/1,
'enc_Params'/1,
'enc_EncodedGeneralToken'/1,
'enc_PwdCertToken'/1,
'enc_EncodedPwdCertToken'/1,
'enc_CryptoToken'/1,
'enc_H235Key'/1,
'enc_KeySignedMaterial'/1,
'enc_EncodedKeySignedMaterial'/1,
'enc_H235CertificateSignature'/1,
'enc_ReturnSig'/1,
'enc_EncodedReturnSig'/1,
'enc_KeySyncMaterial'/1,
'enc_EncodedKeySyncMaterial'/1
]).

-export([
'dec_ChallengeString'/1,
'dec_TimeStamp'/1,
'dec_RandomVal'/1,
'dec_Password'/1,
'dec_Identifier'/1,
'dec_KeyMaterial'/1,
'dec_NonStandardParameter'/1,
'dec_DHset'/1,
'dec_ECpoint'/1,
'dec_ECKASDH'/1,
'dec_ECGDSASignature'/1,
'dec_TypedCertificate'/1,
'dec_AuthenticationBES'/1,
'dec_AuthenticationMechanism'/1,
'dec_ClearToken'/1,
'dec_IV8'/1,
'dec_IV16'/1,
'dec_Params'/1,
'dec_EncodedGeneralToken'/1,
'dec_PwdCertToken'/1,
'dec_EncodedPwdCertToken'/1,
'dec_CryptoToken'/1,
'dec_H235Key'/1,
'dec_KeySignedMaterial'/1,
'dec_EncodedKeySignedMaterial'/1,
'dec_H235CertificateSignature'/1,
'dec_ReturnSig'/1,
'dec_EncodedReturnSig'/1,
'dec_KeySyncMaterial'/1,
'dec_EncodedKeySyncMaterial'/1
]).

-export([info/0]).


-export([encode/2,decode/2]).

encoding_rule() -> per.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try complete(encode_disp(Type, Data)) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception when Class =:= error; Class =:= exit ->
      case Exception of
        {error,Reason}=Error ->
          Error;
        Reason ->
         {error,{asn1,Reason}}
      end
end.

decode(Type,Data) ->
try decode_disp(Type, Data) of
  {Result,Rest} ->
    {ok,Result}
  catch
    Class:Exception when Class =:= error; Class =:= exit ->
      case Exception of
        {error,Reason}=Error ->
          Error;
        Reason ->
         {error,{asn1,Reason}}
      end
end.

encode_disp('ChallengeString',Data) -> 'enc_ChallengeString'(Data);
encode_disp('TimeStamp',Data) -> 'enc_TimeStamp'(Data);
encode_disp('RandomVal',Data) -> 'enc_RandomVal'(Data);
encode_disp('Password',Data) -> 'enc_Password'(Data);
encode_disp('Identifier',Data) -> 'enc_Identifier'(Data);
encode_disp('KeyMaterial',Data) -> 'enc_KeyMaterial'(Data);
encode_disp('NonStandardParameter',Data) -> 'enc_NonStandardParameter'(Data);
encode_disp('DHset',Data) -> 'enc_DHset'(Data);
encode_disp('ECpoint',Data) -> 'enc_ECpoint'(Data);
encode_disp('ECKASDH',Data) -> 'enc_ECKASDH'(Data);
encode_disp('ECGDSASignature',Data) -> 'enc_ECGDSASignature'(Data);
encode_disp('TypedCertificate',Data) -> 'enc_TypedCertificate'(Data);
encode_disp('AuthenticationBES',Data) -> 'enc_AuthenticationBES'(Data);
encode_disp('AuthenticationMechanism',Data) -> 'enc_AuthenticationMechanism'(Data);
encode_disp('ClearToken',Data) -> 'enc_ClearToken'(Data);
encode_disp('IV8',Data) -> 'enc_IV8'(Data);
encode_disp('IV16',Data) -> 'enc_IV16'(Data);
encode_disp('Params',Data) -> 'enc_Params'(Data);
encode_disp('EncodedGeneralToken',Data) -> 'enc_EncodedGeneralToken'(Data);
encode_disp('PwdCertToken',Data) -> 'enc_PwdCertToken'(Data);
encode_disp('EncodedPwdCertToken',Data) -> 'enc_EncodedPwdCertToken'(Data);
encode_disp('CryptoToken',Data) -> 'enc_CryptoToken'(Data);
encode_disp('H235Key',Data) -> 'enc_H235Key'(Data);
encode_disp('KeySignedMaterial',Data) -> 'enc_KeySignedMaterial'(Data);
encode_disp('EncodedKeySignedMaterial',Data) -> 'enc_EncodedKeySignedMaterial'(Data);
encode_disp('H235CertificateSignature',Data) -> 'enc_H235CertificateSignature'(Data);
encode_disp('ReturnSig',Data) -> 'enc_ReturnSig'(Data);
encode_disp('EncodedReturnSig',Data) -> 'enc_EncodedReturnSig'(Data);
encode_disp('KeySyncMaterial',Data) -> 'enc_KeySyncMaterial'(Data);
encode_disp('EncodedKeySyncMaterial',Data) -> 'enc_EncodedKeySyncMaterial'(Data);
encode_disp(Type,_Data) -> exit({error,{asn1,{undefined_type,Type}}}).


decode_disp('ChallengeString',Data) -> 'dec_ChallengeString'(Data);
decode_disp('TimeStamp',Data) -> 'dec_TimeStamp'(Data);
decode_disp('RandomVal',Data) -> 'dec_RandomVal'(Data);
decode_disp('Password',Data) -> 'dec_Password'(Data);
decode_disp('Identifier',Data) -> 'dec_Identifier'(Data);
decode_disp('KeyMaterial',Data) -> 'dec_KeyMaterial'(Data);
decode_disp('NonStandardParameter',Data) -> 'dec_NonStandardParameter'(Data);
decode_disp('DHset',Data) -> 'dec_DHset'(Data);
decode_disp('ECpoint',Data) -> 'dec_ECpoint'(Data);
decode_disp('ECKASDH',Data) -> 'dec_ECKASDH'(Data);
decode_disp('ECGDSASignature',Data) -> 'dec_ECGDSASignature'(Data);
decode_disp('TypedCertificate',Data) -> 'dec_TypedCertificate'(Data);
decode_disp('AuthenticationBES',Data) -> 'dec_AuthenticationBES'(Data);
decode_disp('AuthenticationMechanism',Data) -> 'dec_AuthenticationMechanism'(Data);
decode_disp('ClearToken',Data) -> 'dec_ClearToken'(Data);
decode_disp('IV8',Data) -> 'dec_IV8'(Data);
decode_disp('IV16',Data) -> 'dec_IV16'(Data);
decode_disp('Params',Data) -> 'dec_Params'(Data);
decode_disp('EncodedGeneralToken',Data) -> 'dec_EncodedGeneralToken'(Data);
decode_disp('PwdCertToken',Data) -> 'dec_PwdCertToken'(Data);
decode_disp('EncodedPwdCertToken',Data) -> 'dec_EncodedPwdCertToken'(Data);
decode_disp('CryptoToken',Data) -> 'dec_CryptoToken'(Data);
decode_disp('H235Key',Data) -> 'dec_H235Key'(Data);
decode_disp('KeySignedMaterial',Data) -> 'dec_KeySignedMaterial'(Data);
decode_disp('EncodedKeySignedMaterial',Data) -> 'dec_EncodedKeySignedMaterial'(Data);
decode_disp('H235CertificateSignature',Data) -> 'dec_H235CertificateSignature'(Data);
decode_disp('ReturnSig',Data) -> 'dec_ReturnSig'(Data);
decode_disp('EncodedReturnSig',Data) -> 'dec_EncodedReturnSig'(Data);
decode_disp('KeySyncMaterial',Data) -> 'dec_KeySyncMaterial'(Data);
decode_disp('EncodedKeySyncMaterial',Data) -> 'dec_EncodedKeySyncMaterial'(Data);
decode_disp(Type,_Data) -> exit({error,{asn1,{undefined_type,Type}}}).




info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.
'enc_ChallengeString'(Val) ->
Enc1@len = byte_size(Val),
Enc1@len@sub = Enc1@len - 8,
if 0 =< Enc1@len@sub, Enc1@len@sub < 121 ->
[<<Enc1@len@sub:7>>,
align|Val]
end.


dec_ChallengeString(Bytes) ->
begin
<<V1@V0:7/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 8,
V1@Pad5 = bit_size(V1@Buf1) band 7,
<<_:V1@Pad5,V1@V3:V1@Add2/binary-unit:8,V1@Buf4/bitstring>> = V1@Buf1,
V1@Conv7 = binary:copy(V1@V3),
{V1@Conv7,V1@Buf4}
end.

'enc_TimeStamp'(Val) ->
Val@sub = Val - 1,
if 0 =< Val@sub, Val@sub < 4294967295 ->
begin
Val@sub@bin = binary:encode_unsigned(Val@sub),
Val@sub@bin_size0 = byte_size(Val@sub@bin),
Val@sub@bin_size = Val@sub@bin_size0 - 1,
[<<Val@sub@bin_size:2>>,
align|Val@sub@bin]
end;
true ->
exit({error,{asn1,{illegal_value,Val}}})
end.


dec_TimeStamp(Bytes) ->
begin
<<V1@V0:2/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
V1@Pad5 = bit_size(V1@Buf1) band 7,
<<_:V1@Pad5,V1@V3:V1@Add2/unsigned-unit:8,V1@Buf4/bitstring>> = V1@Buf1,
V1@Add7 = V1@V3 + 1,
{V1@Add7,V1@Buf4}
end.

'enc_RandomVal'(Val) ->
[align|encode_unconstrained_number(Val)].


dec_RandomVal(Bytes) ->
begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> when V1@V5 =/= 0 ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/signed-unit:8,V1@Buf9/bitstring>> = V1@Buf1,
{V1@V8,V1@Buf9}
end.

'enc_Password'(Val) ->
Enc1@len = length(Val),
Enc1@bin = encode_chars_16bit(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 7 =:= 0 ->
[<<Enc1@len@sub:7>>,
align|Enc1@bin]
end.


dec_Password(Bytes) ->
begin
<<V1@V0:7/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
V1@Pad5 = bit_size(V1@Buf1) band 7,
<<_:V1@Pad5,V1@V3:V1@Add2/binary-unit:16,V1@Buf4/bitstring>> = V1@Buf1,
{V1@V7,V1@Buf8}  = {decode_chars_16bit(V1@V3),V1@Buf4},
{V1@V7,V1@Buf8}
end.

'enc_Identifier'(Val) ->
Enc1@len = length(Val),
Enc1@bin = encode_chars_16bit(Val),
Enc1@len@sub = Enc1@len - 1,
if Enc1@len@sub bsr 7 =:= 0 ->
[<<Enc1@len@sub:7>>,
align|Enc1@bin]
end.


dec_Identifier(Bytes) ->
begin
<<V1@V0:7/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Add2 = V1@V0 + 1,
V1@Pad5 = bit_size(V1@Buf1) band 7,
<<_:V1@Pad5,V1@V3:V1@Add2/binary-unit:16,V1@Buf4/bitstring>> = V1@Buf1,
{V1@V7,V1@Buf8}  = {decode_chars_16bit(V1@V3),V1@Buf4},
{V1@V7,V1@Buf8}
end.

'enc_KeyMaterial'(Val) ->
Enc1@bits = bit_size(Val),
Enc1@bits@sub = Enc1@bits - 1,
if Enc1@bits@sub bsr 11 =:= 0 ->
[align,
<<Enc1@bits@sub:16>>|Val]
end.


dec_KeyMaterial(Bytes) ->
begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Add4 = V1@V0 + 1,
<<V1@V5:V1@Add4/binary-unit:1,V1@Buf6/bitstring>> = V1@Buf1,
{V1@V7,V1@Buf8}  = {list_to_bitstring([V1@V5]),V1@Buf6},
{V1@V7,V1@Buf8}
end.

'enc_NonStandardParameter'(Val) ->
[align,
begin
Enc1@element = element(2, Val),
Enc2@bin = encode_oid(Enc1@element),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end|begin
Enc3@element = element(3, Val),
Enc4@len = byte_size(Enc3@element),
if Enc4@len < 128 ->
[Enc4@len|Enc3@element];
Enc4@len < 16384 ->
[<<2:2,Enc4@len:14>>|Enc3@element];
true ->
encode_fragmented(Enc3@element, 8)
end
end].


dec_NonStandardParameter(Bytes) ->

%% attribute number 1 with type OBJECT IDENTIFIER
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/binary-unit:8,V1@Buf9/bitstring>> = V1@Buf1,
V1@Conv10 = binary_to_list(V1@V8),
{V1@V11,V1@Buf12}  = {decode_oid(V1@Conv10),V1@Buf9},
{V1@V11,V1@Buf12}
end,

%% attribute number 2 with type OCTET STRING
{Term2,Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
V2@Conv8 = binary:copy(V2@V0),
{V2@Conv8,V2@Buf1}
end,
{{'NonStandardParameter',Term1,Term2},Bytes2}.

'enc_DHset'(Val) ->
[begin
Enc2@element = element(2, Val),
Enc3@bits = bit_size(Enc2@element),
if Enc3@bits < 2049 ->
[<<0:1>>,
align,
<<Enc3@bits:16>>,
Enc2@element,
align]
end
end,
begin
Enc4@element = element(3, Val),
Enc5@bits = bit_size(Enc4@element),
if Enc5@bits < 2049 ->
[<<Enc5@bits:16>>,
Enc4@element,
align]
end
end|begin
Enc6@element = element(4, Val),
Enc7@bits = bit_size(Enc6@element),
if Enc7@bits < 2049 ->
[<<Enc7@bits:16>>|Enc6@element]
end
end].


dec_DHset(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute number 1 with type BIT STRING
{Term1,Bytes2} = begin
V2@Pad2 = bit_size(Bytes1) band 7,
<<_:V2@Pad2,V2@V0:2/unsigned-unit:8,V2@V4:V2@V0/binary-unit:1,V2@Buf5/bitstring>> = Bytes1,
{V2@V6,V2@Buf7}  = {list_to_bitstring([V2@V4]),V2@Buf5},
{V2@V6,V2@Buf7}
end,

%% attribute number 2 with type BIT STRING
{Term2,Bytes3} = begin
V3@Pad2 = bit_size(Bytes2) band 7,
<<_:V3@Pad2,V3@V0:2/unsigned-unit:8,V3@V4:V3@V0/binary-unit:1,V3@Buf5/bitstring>> = Bytes2,
{V3@V6,V3@Buf7}  = {list_to_bitstring([V3@V4]),V3@Buf5},
{V3@V6,V3@Buf7}
end,

%% attribute number 3 with type BIT STRING
{Term3,Bytes4} = begin
V4@Pad2 = bit_size(Bytes3) band 7,
<<_:V4@Pad2,V4@V0:2/unsigned-unit:8,V4@V4:V4@V0/binary-unit:1,V4@Buf5/bitstring>> = Bytes3,
{V4@V6,V4@Buf7}  = {list_to_bitstring([V4@V4]),V4@Buf5},
{V4@V6,V4@Buf7}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V5@V0,V5@Buf1} = case Bytes4 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
V5@Pad6 = bit_size(V5@Buf2) band 7,
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<_:V5@Pad6,0:1,V5@V8:7,V5@Buf9/bitstring>> when V5@V8 =/= 0 ->
{V5@V8,V5@Buf9};
<<_:V5@Pad6,1:1,0:1,V5@V9:14,V5@Buf10/bitstring>> when V5@V9 =/= 0 ->
{V5@V9,V5@Buf10}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V11:V5@V0/bitstring-unit:1,V5@Buf12/bitstring>> = V5@Buf1,
{V5@V11,V5@Buf12}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
{{'DHset',Term1,Term2,Term3},Bytes6}.

'enc_ECpoint'(Val) ->
[begin
Enc1@element = element(2, Val),
Enc2@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1,0:1>>;
true ->
<<0:1,0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,1:1,0:1>>;
true ->
<<0:1,1:1,1:1>>
end
end
end,
begin
Enc4@element = element(2, Val),
if Enc4@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc5@bits = bit_size(Enc4@element),
if Enc5@bits < 512 ->
[align,
<<Enc5@bits:16>>|Enc4@element]
end
end
end
end|begin
Enc7@element = element(3, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc8@bits = bit_size(Enc7@element),
if Enc8@bits < 512 ->
[align,
<<Enc8@bits:16>>|Enc7@element]
end
end
end
end].


dec_ECpoint(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute number 1 with type BIT STRING
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
begin
V3@Pad2 = bit_size(Bytes2) band 7,
<<_:V3@Pad2,V3@V0:2/unsigned-unit:8,V3@V4:V3@V0/binary-unit:1,V3@Buf5/bitstring>> = Bytes2,
{V3@V6,V3@Buf7}  = {list_to_bitstring([V3@V4]),V3@Buf5},
{V3@V6,V3@Buf7}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute number 2 with type BIT STRING
{Term2,Bytes4} = case Opt band 1 of
1 ->
begin
V4@Pad2 = bit_size(Bytes3) band 7,
<<_:V4@Pad2,V4@V0:2/unsigned-unit:8,V4@V4:V4@V0/binary-unit:1,V4@Buf5/bitstring>> = Bytes3,
{V4@V6,V4@Buf7}  = {list_to_bitstring([V4@V4]),V4@Buf5},
{V4@V6,V4@Buf7}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V5@V0,V5@Buf1} = case Bytes4 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
V5@Pad6 = bit_size(V5@Buf2) band 7,
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<_:V5@Pad6,0:1,V5@V8:7,V5@Buf9/bitstring>> when V5@V8 =/= 0 ->
{V5@V8,V5@Buf9};
<<_:V5@Pad6,1:1,0:1,V5@V9:14,V5@Buf10/bitstring>> when V5@V9 =/= 0 ->
{V5@V9,V5@Buf10}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V11:V5@V0/bitstring-unit:1,V5@Buf12/bitstring>> = V5@Buf1,
{V5@V11,V5@Buf12}
end,
Bytes6= skipextensions(Bytes5, 1, Extensions),
{{'ECpoint',Term1,Term2},Bytes6}.

'enc_ECKASDH'(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= eckasdhp ->
[<<0:1,0:1>>|enc_ECKASDH_eckasdhp(ChoiceVal)];
ChoiceTag =:= eckasdh2 ->
[<<0:1,1:1>>|enc_ECKASDH_eckasdh2(ChoiceVal)]
end.
'enc_ECKASDH_eckasdhp'(Val) ->
[begin
Enc1@element = element(2, Val),
enc_ECpoint(Enc1@element)
end,
align,
begin
Enc2@element = element(3, Val),
Enc3@bits = bit_size(Enc2@element),
if Enc3@bits < 512 ->
[<<Enc3@bits:16>>|Enc2@element]
end
end,
begin
Enc4@element = element(4, Val),
enc_ECpoint(Enc4@element)
end,
align,
begin
Enc5@element = element(5, Val),
Enc6@bits = bit_size(Enc5@element),
if Enc6@bits < 512 ->
[<<Enc6@bits:16>>,
Enc5@element,
align]
end
end|begin
Enc7@element = element(6, Val),
Enc8@bits = bit_size(Enc7@element),
if Enc8@bits < 512 ->
[<<Enc8@bits:16>>|Enc7@element]
end
end].

dec_ECKASDH_eckasdhp(Bytes) ->

%% attribute number 1 with type ECpoint
{Term1,Bytes1} = dec_ECpoint(Bytes),

%% attribute number 2 with type BIT STRING
{Term2,Bytes2} = begin
V1@Pad2 = bit_size(Bytes1) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@V4:V1@V0/binary-unit:1,V1@Buf5/bitstring>> = Bytes1,
{V1@V6,V1@Buf7}  = {list_to_bitstring([V1@V4]),V1@Buf5},
{V1@V6,V1@Buf7}
end,

%% attribute number 3 with type ECpoint
{Term3,Bytes3} = dec_ECpoint(Bytes2),

%% attribute number 4 with type BIT STRING
{Term4,Bytes4} = begin
V2@Pad2 = bit_size(Bytes3) band 7,
<<_:V2@Pad2,V2@V0:2/unsigned-unit:8,V2@V4:V2@V0/binary-unit:1,V2@Buf5/bitstring>> = Bytes3,
{V2@V6,V2@Buf7}  = {list_to_bitstring([V2@V4]),V2@Buf5},
{V2@V6,V2@Buf7}
end,

%% attribute number 5 with type BIT STRING
{Term5,Bytes5} = begin
V3@Pad2 = bit_size(Bytes4) band 7,
<<_:V3@Pad2,V3@V0:2/unsigned-unit:8,V3@V4:V3@V0/binary-unit:1,V3@Buf5/bitstring>> = Bytes4,
{V3@V6,V3@Buf7}  = {list_to_bitstring([V3@V4]),V3@Buf5},
{V3@V6,V3@Buf7}
end,
{{'ECKASDH_eckasdhp',Term1,Term2,Term3,Term4,Term5},Bytes5}.

'enc_ECKASDH_eckasdh2'(Val) ->
[begin
Enc1@element = element(2, Val),
enc_ECpoint(Enc1@element)
end,
align,
begin
Enc2@element = element(3, Val),
Enc3@bits = bit_size(Enc2@element),
if Enc3@bits < 512 ->
[<<Enc3@bits:16>>|Enc2@element]
end
end,
begin
Enc4@element = element(4, Val),
enc_ECpoint(Enc4@element)
end,
align,
begin
Enc5@element = element(5, Val),
Enc6@bits = bit_size(Enc5@element),
if Enc6@bits < 512 ->
[<<Enc6@bits:16>>,
Enc5@element,
align]
end
end|begin
Enc7@element = element(6, Val),
Enc8@bits = bit_size(Enc7@element),
if Enc8@bits < 512 ->
[<<Enc8@bits:16>>|Enc7@element]
end
end].

dec_ECKASDH_eckasdh2(Bytes) ->

%% attribute number 1 with type ECpoint
{Term1,Bytes1} = dec_ECpoint(Bytes),

%% attribute number 2 with type BIT STRING
{Term2,Bytes2} = begin
V1@Pad2 = bit_size(Bytes1) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@V4:V1@V0/binary-unit:1,V1@Buf5/bitstring>> = Bytes1,
{V1@V6,V1@Buf7}  = {list_to_bitstring([V1@V4]),V1@Buf5},
{V1@V6,V1@Buf7}
end,

%% attribute number 3 with type ECpoint
{Term3,Bytes3} = dec_ECpoint(Bytes2),

%% attribute number 4 with type BIT STRING
{Term4,Bytes4} = begin
V2@Pad2 = bit_size(Bytes3) band 7,
<<_:V2@Pad2,V2@V0:2/unsigned-unit:8,V2@V4:V2@V0/binary-unit:1,V2@Buf5/bitstring>> = Bytes3,
{V2@V6,V2@Buf7}  = {list_to_bitstring([V2@V4]),V2@Buf5},
{V2@V6,V2@Buf7}
end,

%% attribute number 5 with type BIT STRING
{Term5,Bytes5} = begin
V3@Pad2 = bit_size(Bytes4) band 7,
<<_:V3@Pad2,V3@V0:2/unsigned-unit:8,V3@V4:V3@V0/binary-unit:1,V3@Buf5/bitstring>> = Bytes4,
{V3@V6,V3@Buf7}  = {list_to_bitstring([V3@V4]),V3@Buf5},
{V3@V6,V3@Buf7}
end,
{{'ECKASDH_eckasdh2',Term1,Term2,Term3,Term4,Term5},Bytes5}.



dec_ECKASDH(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:1/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
'dec_ECKASDH_eckasdhp'(Bytes2)
end,
{{eckasdhp,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
'dec_ECKASDH_eckasdh2'(Bytes2)
end,
{{eckasdh2,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
V1@Pad6 = bit_size(V1@Buf2) band 7,
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<_:V1@Pad6,0:1,V1@V8:7,V1@Buf9/bitstring>> when V1@V8 =/= 0 ->
{V1@V8,V1@Buf9};
<<_:V1@Pad6,1:1,0:1,V1@V9:14,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10}
end,
<<V1@V11:V1@V3/unit:8,V1@Buf12/bitstring>> = V1@Buf4,
{V1@V11,V1@Buf12}
end,
{V1@V0,V1@Buf1}
end,
begin
V2@Pad3 = bit_size(Bytes2) band 7,
{V2@V0,V2@Buf1} = case Bytes2 of
<<_:V2@Pad3,0:1,V2@V5:7,V2@V7:V2@V5/binary-unit:8,V2@Buf8/bitstring>> ->
{V2@V7,V2@Buf8};
<<_:V2@Pad3,1:1,0:1,V2@V6:14,V2@V8:V2@V6/binary-unit:8,V2@Buf9/bitstring>> ->
{V2@V8,V2@Buf9};
<<_:V2@Pad3,1:1,1:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V8,V2@Buf9}  = decode_fragmented(V2@V6, V2@Buf7, 8),
{V2@V8,V2@Buf9}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
'enc_ECGDSASignature'(Val) ->
[align,
begin
Enc1@element = element(2, Val),
Enc2@bits = bit_size(Enc1@element),
if Enc2@bits < 512 ->
[<<Enc2@bits:16>>,
Enc1@element,
align]
end
end|begin
Enc3@element = element(3, Val),
Enc4@bits = bit_size(Enc3@element),
if Enc4@bits < 512 ->
[<<Enc4@bits:16>>|Enc3@element]
end
end].


dec_ECGDSASignature(Bytes) ->

%% attribute number 1 with type BIT STRING
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@V4:V1@V0/binary-unit:1,V1@Buf5/bitstring>> = Bytes,
{V1@V6,V1@Buf7}  = {list_to_bitstring([V1@V4]),V1@Buf5},
{V1@V6,V1@Buf7}
end,

%% attribute number 2 with type BIT STRING
{Term2,Bytes2} = begin
V2@Pad2 = bit_size(Bytes1) band 7,
<<_:V2@Pad2,V2@V0:2/unsigned-unit:8,V2@V4:V2@V0/binary-unit:1,V2@Buf5/bitstring>> = Bytes1,
{V2@V6,V2@Buf7}  = {list_to_bitstring([V2@V4]),V2@Buf5},
{V2@V6,V2@Buf7}
end,
{{'ECGDSASignature',Term1,Term2},Bytes2}.

'enc_TypedCertificate'(Val) ->
[begin
Enc2@element = element(2, Val),
Enc3@bin = encode_oid(Enc2@element),
Enc3@len = byte_size(Enc3@bin),
if Enc3@len < 128 ->
[<<0:1>>,
align,
Enc3@len|Enc3@bin];
Enc3@len < 16384 ->
[<<0:1>>,
align,
<<2:2,Enc3@len:14>>|Enc3@bin];
true ->
[<<0:1>>,
align|encode_fragmented(Enc3@bin, 8)]
end
end|begin
Enc4@element = element(3, Val),
Enc5@len = byte_size(Enc4@element),
if Enc5@len < 128 ->
[Enc5@len|Enc4@element];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc4@element];
true ->
encode_fragmented(Enc4@element, 8)
end
end].


dec_TypedCertificate(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute number 1 with type OBJECT IDENTIFIER
{Term1,Bytes2} = begin
V2@Pad3 = bit_size(Bytes1) band 7,
{V2@V0,V2@Buf1} = case Bytes1 of
<<_:V2@Pad3,0:1,V2@V5:7,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<_:V2@Pad3,1:1,0:1,V2@V6:14,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7}
end,
<<V2@V8:V2@V0/binary-unit:8,V2@Buf9/bitstring>> = V2@Buf1,
V2@Conv10 = binary_to_list(V2@V8),
{V2@V11,V2@Buf12}  = {decode_oid(V2@Conv10),V2@Buf9},
{V2@V11,V2@Buf12}
end,

%% attribute number 2 with type OCTET STRING
{Term2,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:7,V3@V5:V3@V3/binary-unit:8,V3@Buf6/bitstring>> ->
{V3@V5,V3@Buf6};
<<1:1,0:1,V3@V4:14,V3@V6:V3@V4/binary-unit:8,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7};
<<1:1,1:1,V3@V4:6,V3@Buf5/bitstring>> ->
{V3@V6,V3@Buf7}  = decode_fragmented(V3@V4, V3@Buf5, 8),
{V3@V6,V3@Buf7}
end,
V3@Conv8 = binary:copy(V3@V0),
{V3@Conv8,V3@Buf1}
end,

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<_:7,0:1,V4@V7:7,V4@Buf8/bitstring>> when V4@V7 =/= 0 ->
{V4@V7,V4@Buf8};
<<_:7,1:1,0:1,V4@V8:14,V4@Buf9/bitstring>> when V4@V8 =/= 0 ->
{V4@V8,V4@Buf9}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V10:V4@V0/bitstring-unit:1,V4@Buf11/bitstring>> = V4@Buf1,
{V4@V10,V4@Buf11}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
{{'TypedCertificate',Term1,Term2},Bytes5}.

'enc_AuthenticationBES'(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= default ->
<<0:1,0:1>>;
ChoiceTag =:= radius ->
<<0:1,1:1>>
end.


dec_AuthenticationBES(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:1/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
ignore,
{'NULL',Bytes2}
end
end,
{{default,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
ignore,
{'NULL',Bytes2}
end
end,
{{radius,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
V1@Pad6 = bit_size(V1@Buf2) band 7,
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<_:V1@Pad6,0:1,V1@V8:7,V1@Buf9/bitstring>> when V1@V8 =/= 0 ->
{V1@V8,V1@Buf9};
<<_:V1@Pad6,1:1,0:1,V1@V9:14,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10}
end,
<<V1@V11:V1@V3/unit:8,V1@Buf12/bitstring>> = V1@Buf4,
{V1@V11,V1@Buf12}
end,
{V1@V0,V1@Buf1}
end,
begin
V2@Pad3 = bit_size(Bytes2) band 7,
{V2@V0,V2@Buf1} = case Bytes2 of
<<_:V2@Pad3,0:1,V2@V5:7,V2@V7:V2@V5/binary-unit:8,V2@Buf8/bitstring>> ->
{V2@V7,V2@Buf8};
<<_:V2@Pad3,1:1,0:1,V2@V6:14,V2@V8:V2@V6/binary-unit:8,V2@Buf9/bitstring>> ->
{V2@V8,V2@Buf9};
<<_:V2@Pad3,1:1,1:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V8,V2@Buf9}  = decode_fragmented(V2@V6, V2@Buf7, 8),
{V2@V8,V2@Buf9}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
'enc_AuthenticationMechanism'(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= dhExch ->
<<0:1,0:3>>;
ChoiceTag =:= pwdSymEnc ->
<<0:1,1:3>>;
ChoiceTag =:= pwdHash ->
<<0:1,2:3>>;
ChoiceTag =:= certSign ->
<<0:1,3:3>>;
ChoiceTag =:= ipsec ->
<<0:1,4:3>>;
ChoiceTag =:= tls ->
<<0:1,5:3>>;
ChoiceTag =:= nonStandard ->
[<<0:1,6:3>>|enc_NonStandardParameter(ChoiceVal)];
ChoiceTag =:= authenticationBES ->
begin
Enc8@output = enc_AuthenticationBES(ChoiceVal),
Enc8@bin = complete(Enc8@output),
Enc8@len = byte_size(Enc8@bin),
if Enc8@len < 128 ->
[<<1:1,0:7>>,
align,
Enc8@len|Enc8@bin];
Enc8@len < 16384 ->
[<<1:1,0:7>>,
align,
<<2:2,Enc8@len:14>>|Enc8@bin];
true ->
[<<1:1,0:7>>,
align|encode_fragmented(Enc8@bin, 8)]
end
end
end.


dec_AuthenticationMechanism(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:3/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
ignore,
{'NULL',Bytes2}
end
end,
{{dhExch,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
begin
ignore,
{'NULL',Bytes2}
end
end,
{{pwdSymEnc,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
begin
ignore,
{'NULL',Bytes2}
end
end,
{{pwdHash,Val},NewBytes};
3 ->
{Val,NewBytes} = begin
begin
ignore,
{'NULL',Bytes2}
end
end,
{{certSign,Val},NewBytes};
4 ->
{Val,NewBytes} = begin
begin
ignore,
{'NULL',Bytes2}
end
end,
{{ipsec,Val},NewBytes};
5 ->
{Val,NewBytes} = begin
begin
ignore,
{'NULL',Bytes2}
end
end,
{{tls,Val},NewBytes};
6 ->
{Val,NewBytes} = begin
dec_NonStandardParameter(Bytes2)
end,
{{nonStandard,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
V1@Pad6 = bit_size(V1@Buf2) band 7,
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<_:V1@Pad6,0:1,V1@V8:7,V1@Buf9/bitstring>> when V1@V8 =/= 0 ->
{V1@V8,V1@Buf9};
<<_:V1@Pad6,1:1,0:1,V1@V9:14,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10}
end,
<<V1@V11:V1@V3/unit:8,V1@Buf12/bitstring>> = V1@Buf4,
{V1@V11,V1@Buf12}
end,
{V1@V0,V1@Buf1}
end,
begin
V2@Pad3 = bit_size(Bytes2) band 7,
{V2@V0,V2@Buf1} = case Bytes2 of
<<_:V2@Pad3,0:1,V2@V5:7,V2@V7:V2@V5/binary-unit:8,V2@Buf8/bitstring>> ->
{V2@V7,V2@Buf8};
<<_:V2@Pad3,1:1,0:1,V2@V6:14,V2@V8:V2@V6/binary-unit:8,V2@Buf9/bitstring>> ->
{V2@V8,V2@Buf9};
<<_:V2@Pad3,1:1,1:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V8,V2@Buf9}  = decode_fragmented(V2@V6, V2@Buf7, 8),
{V2@V8,V2@Buf9}
end
end,
case Choice of
0 ->
{Val,NewBytes} = begin
{TmpVal,_} = dec_AuthenticationBES(V2@V0),
{TmpVal,V2@Buf1}
end,
{{authenticationBES,Val},NewBytes};
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
'enc_ClearToken'(Val) ->
Enc9@bitmap = extension_bitmap(Val, 11, 13),
Extensions = if Enc9@bitmap =:= 0 ->
[];
true ->
<<1:7,Enc9@bitmap:2>>
end,
[begin
Enc1@element = element(3, Val),
if Extensions =:= [] ->
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc1@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc2@element = element(4, Val),
Enc3@element = element(5, Val),
if Enc2@element =:= asn1_NOVALUE ->
if Enc3@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc3@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc4@element = element(6, Val),
Enc5@element = element(7, Val),
if Enc4@element =:= asn1_NOVALUE ->
if Enc5@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc5@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc6@element = element(8, Val),
Enc7@element = element(9, Val),
if Enc6@element =:= asn1_NOVALUE ->
if Enc7@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc7@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc8@element = element(10, Val),
if Enc8@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
align,
begin
Enc11@element = element(2, Val),
Enc12@bin = encode_oid(Enc11@element),
Enc12@len = byte_size(Enc12@bin),
if Enc12@len < 128 ->
[Enc12@len|Enc12@bin];
Enc12@len < 16384 ->
[<<2:2,Enc12@len:14>>|Enc12@bin];
true ->
encode_fragmented(Enc12@bin, 8)
end
end,
begin
Enc13@element = element(3, Val),
if Enc13@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc13@element@sub = Enc13@element - 1,
if 0 =< Enc13@element@sub, Enc13@element@sub < 4294967295 ->
begin
Enc13@element@sub@bin = binary:encode_unsigned(Enc13@element@sub),
Enc13@element@sub@bin_size0 = byte_size(Enc13@element@sub@bin),
Enc13@element@sub@bin_size = Enc13@element@sub@bin_size0 - 1,
[<<Enc13@element@sub@bin_size:2,0:6>>|Enc13@element@sub@bin]
end;
true ->
exit({error,{asn1,{illegal_value,Enc13@element}}})
end
end
end
end,
begin
Enc16@element = element(4, Val),
if Enc16@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc17@len = length(Enc16@element),
Enc17@bin = encode_chars_16bit(Enc16@element),
Enc17@len@sub = Enc17@len - 1,
if Enc17@len@sub bsr 7 =:= 0 ->
[<<Enc17@len@sub:7,0:1>>|Enc17@bin]
end
end
end
end,
begin
Enc19@element = element(5, Val),
if Enc19@element =:= asn1_NOVALUE ->
[];
true ->
enc_DHset(Enc19@element)
end
end,
begin
Enc21@element = element(6, Val),
if Enc21@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc22@len = byte_size(Enc21@element),
Enc22@len@sub = Enc22@len - 8,
if 0 =< Enc22@len@sub, Enc22@len@sub < 121 ->
[<<Enc22@len@sub:7>>,
align|Enc21@element]
end
end
end
end,
begin
Enc24@element = element(7, Val),
if Enc24@element =:= asn1_NOVALUE ->
[];
true ->
[align|encode_unconstrained_number(Enc24@element)]
end
end,
begin
Enc27@element = element(8, Val),
if Enc27@element =:= asn1_NOVALUE ->
[];
true ->
enc_TypedCertificate(Enc27@element)
end
end,
begin
Enc29@element = element(9, Val),
if Enc29@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc30@len = length(Enc29@element),
Enc30@bin = encode_chars_16bit(Enc29@element),
Enc30@len@sub = Enc30@len - 1,
if Enc30@len@sub bsr 7 =:= 0 ->
[<<Enc30@len@sub:7>>,
align|Enc30@bin]
end
end
end
end,
begin
Enc32@element = element(10, Val),
if Enc32@element =:= asn1_NOVALUE ->
[];
true ->
enc_NonStandardParameter(Enc32@element)
end
end,
Extensions,
begin
Enc34@element = element(11, Val),
if Enc34@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc35@output = enc_ECKASDH(Enc34@element),
Enc35@bin = complete(Enc35@output),
Enc35@len = byte_size(Enc35@bin),
if Enc35@len < 128 ->
[align,
Enc35@len|Enc35@bin];
Enc35@len < 16384 ->
[align,
<<2:2,Enc35@len:14>>|Enc35@bin];
true ->
[align|encode_fragmented(Enc35@bin, 8)]
end
end
end
end|begin
Enc37@element = element(12, Val),
if Enc37@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc39@output = begin
Enc38@len = length(Enc37@element),
Enc38@bin = encode_chars_16bit(Enc37@element),
Enc38@len@sub = Enc38@len - 1,
if Enc38@len@sub bsr 7 =:= 0 ->
[<<Enc38@len@sub:7,0:1>>|Enc38@bin]
end
end,
Enc39@bin = iolist_to_binary(Enc39@output),
Enc39@len = byte_size(Enc39@bin),
if Enc39@len < 128 ->
[align,
Enc39@len|Enc39@bin];
true ->
[align,
<<2:2,Enc39@len:14>>|Enc39@bin]
end
end
end
end].


dec_ClearToken(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute number 1 with type OBJECT IDENTIFIER
{Term1,Bytes3} = begin
V3@Pad3 = bit_size(Bytes2) band 7,
{V3@V0,V3@Buf1} = case Bytes2 of
<<_:V3@Pad3,0:1,V3@V5:7,V3@Buf6/bitstring>> ->
{V3@V5,V3@Buf6};
<<_:V3@Pad3,1:1,0:1,V3@V6:14,V3@Buf7/bitstring>> ->
{V3@V6,V3@Buf7}
end,
<<V3@V8:V3@V0/binary-unit:8,V3@Buf9/bitstring>> = V3@Buf1,
V3@Conv10 = binary_to_list(V3@V8),
{V3@V11,V3@Buf12}  = {decode_oid(V3@Conv10),V3@Buf9},
{V3@V11,V3@Buf12}
end,

%% attribute number 2 with type INTEGER
{Term2,Bytes4} = case (Opt bsr 7) band 1 of
1 ->
begin
<<V4@V0:2/unsigned-unit:1,V4@Buf1/bitstring>> = Bytes3,
V4@Add2 = V4@V0 + 1,
V4@Pad5 = bit_size(V4@Buf1) band 7,
<<_:V4@Pad5,V4@V3:V4@Add2/unsigned-unit:8,V4@Buf4/bitstring>> = V4@Buf1,
V4@Add7 = V4@V3 + 1,
{V4@Add7,V4@Buf4}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute number 3 with type BMPString
{Term3,Bytes5} = case (Opt bsr 6) band 1 of
1 ->
begin
<<V5@V0:7/unsigned-unit:1,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + 1,
V5@Pad5 = bit_size(V5@Buf1) band 7,
<<_:V5@Pad5,V5@V3:V5@Add2/binary-unit:16,V5@Buf4/bitstring>> = V5@Buf1,
{V5@V7,V5@Buf8}  = {decode_chars_16bit(V5@V3),V5@Buf4},
{V5@V7,V5@Buf8}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute number 4 with type DHset
{Term4,Bytes6} = case (Opt bsr 5) band 1 of
1 ->
dec_DHset(Bytes5);
0 ->
{asn1_NOVALUE,Bytes5}
end,

%% attribute number 5 with type OCTET STRING
{Term5,Bytes7} = case (Opt bsr 4) band 1 of
1 ->
begin
<<V6@V0:7/unsigned-unit:1,V6@Buf1/bitstring>> = Bytes6,
V6@Add2 = V6@V0 + 8,
V6@Pad5 = bit_size(V6@Buf1) band 7,
<<_:V6@Pad5,V6@V3:V6@Add2/binary-unit:8,V6@Buf4/bitstring>> = V6@Buf1,
V6@Conv7 = binary:copy(V6@V3),
{V6@Conv7,V6@Buf4}
end;
0 ->
{asn1_NOVALUE,Bytes6}
end,

%% attribute number 6 with type INTEGER
{Term6,Bytes8} = case (Opt bsr 3) band 1 of
1 ->
begin
V7@Pad3 = bit_size(Bytes7) band 7,
{V7@V0,V7@Buf1} = case Bytes7 of
<<_:V7@Pad3,0:1,V7@V5:7,V7@Buf6/bitstring>> when V7@V5 =/= 0 ->
{V7@V5,V7@Buf6};
<<_:V7@Pad3,1:1,0:1,V7@V6:14,V7@Buf7/bitstring>> when V7@V6 =/= 0 ->
{V7@V6,V7@Buf7}
end,
<<V7@V8:V7@V0/signed-unit:8,V7@Buf9/bitstring>> = V7@Buf1,
{V7@V8,V7@Buf9}
end;
0 ->
{asn1_NOVALUE,Bytes7}
end,

%% attribute number 7 with type TypedCertificate
{Term7,Bytes9} = case (Opt bsr 2) band 1 of
1 ->
dec_TypedCertificate(Bytes8);
0 ->
{asn1_NOVALUE,Bytes8}
end,

%% attribute number 8 with type BMPString
{Term8,Bytes10} = case (Opt bsr 1) band 1 of
1 ->
begin
<<V8@V0:7/unsigned-unit:1,V8@Buf1/bitstring>> = Bytes9,
V8@Add2 = V8@V0 + 1,
V8@Pad5 = bit_size(V8@Buf1) band 7,
<<_:V8@Pad5,V8@V3:V8@Add2/binary-unit:16,V8@Buf4/bitstring>> = V8@Buf1,
{V8@V7,V8@Buf8}  = {decode_chars_16bit(V8@V3),V8@Buf4},
{V8@V7,V8@Buf8}
end;
0 ->
{asn1_NOVALUE,Bytes9}
end,

%% attribute number 9 with type NonStandardParameter
{Term9,Bytes11} = case Opt band 1 of
1 ->
dec_NonStandardParameter(Bytes10);
0 ->
{asn1_NOVALUE,Bytes10}
end,

%% Extensions
{Extensions,Bytes12} = case Ext of
0 -> {<<>>,Bytes11};
1 ->
{V9@V0,V9@Buf1} = case Bytes11 of
<<0:1,V9@V3:6,V9@Buf4/bitstring>> ->
V9@Add5 = V9@V3 + 1,
{V9@Add5,V9@Buf4};
<<1:1,V9@Buf2/bitstring>> ->
V9@Pad6 = bit_size(V9@Buf2) band 7,
{V9@V3,V9@Buf4} = case V9@Buf2 of
<<_:V9@Pad6,0:1,V9@V8:7,V9@Buf9/bitstring>> when V9@V8 =/= 0 ->
{V9@V8,V9@Buf9};
<<_:V9@Pad6,1:1,0:1,V9@V9:14,V9@Buf10/bitstring>> when V9@V9 =/= 0 ->
{V9@V9,V9@Buf10}
end,
{V9@V3,V9@Buf4}
end,
<<V9@V11:V9@V0/bitstring-unit:1,V9@Buf12/bitstring>> = V9@Buf1,
{V9@V11,V9@Buf12}
end,

%% attribute number 10 with type ECKASDH
{Term10,Bytes13} = case Extensions of
  <<_:0,1:1,_/bitstring>> ->
begin
V10@Pad3 = bit_size(Bytes12) band 7,
{V10@V0,V10@Buf1} = case Bytes12 of
<<_:V10@Pad3,0:1,V10@V5:7,V10@V7:V10@V5/binary-unit:8,V10@Buf8/bitstring>> ->
{V10@V7,V10@Buf8};
<<_:V10@Pad3,1:1,0:1,V10@V6:14,V10@V8:V10@V6/binary-unit:8,V10@Buf9/bitstring>> ->
{V10@V8,V10@Buf9};
<<_:V10@Pad3,1:1,1:1,V10@V6:6,V10@Buf7/bitstring>> ->
{V10@V8,V10@Buf9}  = decode_fragmented(V10@V6, V10@Buf7, 8),
{V10@V8,V10@Buf9}
end,
{TmpValx10,_} = dec_ECKASDH(V10@V0),
{TmpValx10,V10@Buf1}
end;
_  ->
{asn1_NOVALUE,Bytes12}
end,

%% attribute number 11 with type BMPString
{Term11,Bytes14} = case Extensions of
  <<_:1,1:1,_/bitstring>> ->
begin
V11@Pad3 = bit_size(Bytes13) band 7,
{V11@V0,V11@Buf1} = case Bytes13 of
<<_:V11@Pad3,0:1,V11@V5:7,V11@V7:V11@V5/binary-unit:8,V11@Buf8/bitstring>> ->
{V11@V7,V11@Buf8};
<<_:V11@Pad3,1:1,0:1,V11@V6:14,V11@V8:V11@V6/binary-unit:8,V11@Buf9/bitstring>> ->
{V11@V8,V11@Buf9};
<<_:V11@Pad3,1:1,1:1,V11@V6:6,V11@Buf7/bitstring>> ->
{V11@V8,V11@Buf9}  = decode_fragmented(V11@V6, V11@Buf7, 8),
{V11@V8,V11@Buf9}
end,
{TmpValx11,_} = begin
<<V12@V0:7/unsigned-unit:1,V12@Buf1/bitstring>> = V11@V0,
V12@Add2 = V12@V0 + 1,
V12@Pad5 = bit_size(V12@Buf1) band 7,
<<_:V12@Pad5,V12@V3:V12@Add2/binary-unit:16,V12@Buf4/bitstring>> = V12@Buf1,
{V12@V7,V12@Buf8}  = {decode_chars_16bit(V12@V3),V12@Buf4},
{V12@V7,V12@Buf8}
end,
{TmpValx11,V11@Buf1}
end;
_  ->
{asn1_NOVALUE,Bytes13}
end,
Bytes15= skipextensions(Bytes14, 3, Extensions),
{{'ClearToken',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8,Term9,Term10,Term11},Bytes15}.

'enc_IV8'(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len =:= 8 ->
[align|Val]
end.


dec_IV8(Bytes) ->
begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:8/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv4 = binary:copy(V1@V0),
{V1@Conv4,V1@Buf1}
end.

'enc_IV16'(Val) ->
Enc1@len = byte_size(Val),
if Enc1@len =:= 16 ->
[align|Val]
end.


dec_IV16(Bytes) ->
begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:16/binary-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Conv4 = binary:copy(V1@V0),
{V1@Conv4,V1@Buf1}
end.

'enc_Params'(Val) ->
Enc3@bitmap = extension_bitmap(Val, 4, 5),
Extensions = if Enc3@bitmap =:= 0 ->
[];
true ->
<<0:7,1:1>>
end,
[begin
Enc1@element = element(2, Val),
if Extensions =:= [] ->
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc1@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc2@element = element(3, Val),
if Enc2@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
Enc5@element = element(2, Val),
if Enc5@element =:= asn1_NOVALUE ->
[];
true ->
[align|encode_unconstrained_number(Enc5@element)]
end
end,
begin
Enc8@element = element(3, Val),
if Enc8@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc9@len = byte_size(Enc8@element),
if Enc9@len =:= 8 ->
[align|Enc8@element]
end
end
end
end,
Extensions|begin
Enc11@element = element(4, Val),
if Enc11@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc13@output = begin
Enc12@len = byte_size(Enc11@element),
if Enc12@len =:= 16 ->
Enc11@element
end
end,
Enc13@bin = Enc13@output,
[align,
16|Enc13@bin]
end
end
end].


dec_Params(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:2,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute number 1 with type INTEGER
{Term1,Bytes3} = case (Opt bsr 1) band 1 of
1 ->
begin
V3@Pad3 = bit_size(Bytes2) band 7,
{V3@V0,V3@Buf1} = case Bytes2 of
<<_:V3@Pad3,0:1,V3@V5:7,V3@Buf6/bitstring>> when V3@V5 =/= 0 ->
{V3@V5,V3@Buf6};
<<_:V3@Pad3,1:1,0:1,V3@V6:14,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7}
end,
<<V3@V8:V3@V0/signed-unit:8,V3@Buf9/bitstring>> = V3@Buf1,
{V3@V8,V3@Buf9}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,

%% attribute number 2 with type OCTET STRING
{Term2,Bytes4} = case Opt band 1 of
1 ->
begin
V4@Pad2 = bit_size(Bytes3) band 7,
<<_:V4@Pad2,V4@V0:8/binary-unit:8,V4@Buf1/bitstring>> = Bytes3,
V4@Conv4 = binary:copy(V4@V0),
{V4@Conv4,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% Extensions
{Extensions,Bytes5} = case Ext of
0 -> {<<>>,Bytes4};
1 ->
{V5@V0,V5@Buf1} = case Bytes4 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
V5@Pad6 = bit_size(V5@Buf2) band 7,
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<_:V5@Pad6,0:1,V5@V8:7,V5@Buf9/bitstring>> when V5@V8 =/= 0 ->
{V5@V8,V5@Buf9};
<<_:V5@Pad6,1:1,0:1,V5@V9:14,V5@Buf10/bitstring>> when V5@V9 =/= 0 ->
{V5@V9,V5@Buf10}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V11:V5@V0/bitstring-unit:1,V5@Buf12/bitstring>> = V5@Buf1,
{V5@V11,V5@Buf12}
end,

%% attribute number 3 with type OCTET STRING
{Term3,Bytes6} = case Extensions of
  <<_:0,1:1,_/bitstring>> ->
begin
V6@Pad3 = bit_size(Bytes5) band 7,
{V6@V0,V6@Buf1} = case Bytes5 of
<<_:V6@Pad3,0:1,V6@V5:7,V6@V7:V6@V5/binary-unit:8,V6@Buf8/bitstring>> ->
{V6@V7,V6@Buf8};
<<_:V6@Pad3,1:1,0:1,V6@V6:14,V6@V8:V6@V6/binary-unit:8,V6@Buf9/bitstring>> ->
{V6@V8,V6@Buf9};
<<_:V6@Pad3,1:1,1:1,V6@V6:6,V6@Buf7/bitstring>> ->
{V6@V8,V6@Buf9}  = decode_fragmented(V6@V6, V6@Buf7, 8),
{V6@V8,V6@Buf9}
end,
{TmpValx3,_} = begin
V7@Pad2 = bit_size(V6@V0) band 7,
<<_:V7@Pad2,V7@V0:16/binary-unit:8,V7@Buf1/bitstring>> = V6@V0,
V7@Conv4 = binary:copy(V7@V0),
{V7@Conv4,V7@Buf1}
end,
{TmpValx3,V6@Buf1}
end;
_  ->
{asn1_NOVALUE,Bytes5}
end,
Bytes7= skipextensions(Bytes6, 2, Extensions),
{{'Params',Term1,Term2,Term3},Bytes7}.

'enc_EncodedGeneralToken'(Val) ->
Enc1@output = enc_ClearToken(Val),
Enc1@bin = complete(Enc1@output),
Enc1@len = byte_size(Enc1@bin),
if Enc1@len < 128 ->
[align,
Enc1@len|Enc1@bin];
Enc1@len < 16384 ->
[align,
<<2:2,Enc1@len:14>>|Enc1@bin];
true ->
[align|encode_fragmented(Enc1@bin, 8)]
end.


dec_EncodedGeneralToken(Bytes) ->
begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@V7:V1@V5/binary-unit:8,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@V8:V1@V6/binary-unit:8,V1@Buf9/bitstring>> ->
{V1@V8,V1@Buf9};
<<_:V1@Pad3,1:1,1:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V8,V1@Buf9}  = decode_fragmented(V1@V6, V1@Buf7, 8),
{V1@V8,V1@Buf9}
end,
{V1@V10,V1@Buf11}  = begin
{Tmpval1,_} = dec_ClearToken(V1@V0),
{Tmpval1,V1@Buf1}
end,
{V1@V10,V1@Buf11}
end.

'enc_PwdCertToken'(Val) ->
'enc_ClearToken'(Val).



dec_PwdCertToken(Bytes) ->
dec_ClearToken(Bytes).

'enc_EncodedPwdCertToken'(Val) ->
Enc1@output = enc_PwdCertToken(Val),
Enc1@bin = complete(Enc1@output),
Enc1@len = byte_size(Enc1@bin),
if Enc1@len < 128 ->
[align,
Enc1@len|Enc1@bin];
Enc1@len < 16384 ->
[align,
<<2:2,Enc1@len:14>>|Enc1@bin];
true ->
[align|encode_fragmented(Enc1@bin, 8)]
end.


dec_EncodedPwdCertToken(Bytes) ->
begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@V7:V1@V5/binary-unit:8,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@V8:V1@V6/binary-unit:8,V1@Buf9/bitstring>> ->
{V1@V8,V1@Buf9};
<<_:V1@Pad3,1:1,1:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V8,V1@Buf9}  = decode_fragmented(V1@V6, V1@Buf7, 8),
{V1@V8,V1@Buf9}
end,
{V1@V10,V1@Buf11}  = begin
{Tmpval1,_} = dec_PwdCertToken(V1@V0),
{Tmpval1,V1@Buf1}
end,
{V1@V10,V1@Buf11}
end.

'enc_CryptoToken'(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= cryptoEncryptedToken ->
[<<0:1,0:2>>|enc_CryptoToken_cryptoEncryptedToken(ChoiceVal)];
ChoiceTag =:= cryptoSignedToken ->
[<<0:1,1:2>>|enc_CryptoToken_cryptoSignedToken(ChoiceVal)];
ChoiceTag =:= cryptoHashedToken ->
[<<0:1,2:2>>|enc_CryptoToken_cryptoHashedToken(ChoiceVal)];
ChoiceTag =:= cryptoPwdEncr ->
[<<0:1,3:2>>|enc_CryptoToken_cryptoPwdEncr(ChoiceVal)]
end.
'enc_CryptoToken_cryptoEncryptedToken'(Val) ->
[align,
begin
Enc1@element = element(2, Val),
Enc2@bin = encode_oid(Enc1@element),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end|begin
Enc3@element = element(3, Val),
enc_CryptoToken_cryptoEncryptedToken_token(Enc3@element)
end].
'enc_CryptoToken_cryptoEncryptedToken_token'(Val) ->
[align,
begin
Enc1@element = element(2, Val),
Enc2@bin = encode_oid(Enc1@element),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end,
begin
Enc3@element = element(3, Val),
enc_Params(Enc3@element)
end,
align|begin
Enc4@element = element(4, Val),
Enc5@len = byte_size(Enc4@element),
if Enc5@len < 128 ->
[Enc5@len|Enc4@element];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc4@element];
true ->
encode_fragmented(Enc4@element, 8)
end
end].

dec_CryptoToken_cryptoEncryptedToken_token(Bytes) ->

%% attribute number 1 with type OBJECT IDENTIFIER
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/binary-unit:8,V1@Buf9/bitstring>> = V1@Buf1,
V1@Conv10 = binary_to_list(V1@V8),
{V1@V11,V1@Buf12}  = {decode_oid(V1@Conv10),V1@Buf9},
{V1@V11,V1@Buf12}
end,

%% attribute number 2 with type Params
{Term2,Bytes2} = dec_Params(Bytes1),

%% attribute number 3 with type OCTET STRING
{Term3,Bytes3} = begin
V2@Pad3 = bit_size(Bytes2) band 7,
{V2@V0,V2@Buf1} = case Bytes2 of
<<_:V2@Pad3,0:1,V2@V5:7,V2@V7:V2@V5/binary-unit:8,V2@Buf8/bitstring>> ->
{V2@V7,V2@Buf8};
<<_:V2@Pad3,1:1,0:1,V2@V6:14,V2@V8:V2@V6/binary-unit:8,V2@Buf9/bitstring>> ->
{V2@V8,V2@Buf9};
<<_:V2@Pad3,1:1,1:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V8,V2@Buf9}  = decode_fragmented(V2@V6, V2@Buf7, 8),
{V2@V8,V2@Buf9}
end,
V2@Conv10 = binary:copy(V2@V0),
{V2@Conv10,V2@Buf1}
end,
{{'CryptoToken_cryptoEncryptedToken_token',Term1,Term2,Term3},Bytes3}.


dec_CryptoToken_cryptoEncryptedToken(Bytes) ->

%% attribute number 1 with type OBJECT IDENTIFIER
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/binary-unit:8,V1@Buf9/bitstring>> = V1@Buf1,
V1@Conv10 = binary_to_list(V1@V8),
{V1@V11,V1@Buf12}  = {decode_oid(V1@Conv10),V1@Buf9},
{V1@V11,V1@Buf12}
end,

%% attribute number 2 with type SEQUENCE
{Term2,Bytes2} = 'dec_CryptoToken_cryptoEncryptedToken_token'(Bytes1),
{{'CryptoToken_cryptoEncryptedToken',Term1,Term2},Bytes2}.

'enc_CryptoToken_cryptoSignedToken'(Val) ->
[align,
begin
Enc1@element = element(2, Val),
Enc2@bin = encode_oid(Enc1@element),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end|begin
Enc3@element = element(3, Val),
enc_CryptoToken_cryptoSignedToken_token(Enc3@element)
end].
'enc_CryptoToken_cryptoSignedToken_token'(Val) ->
[begin
Enc1@element = element(2, Val),
enc_EncodedGeneralToken(Enc1@element)
end,
align,
begin
Enc2@element = element(3, Val),
Enc3@bin = encode_oid(Enc2@element),
Enc3@len = byte_size(Enc3@bin),
if Enc3@len < 128 ->
[Enc3@len|Enc3@bin];
Enc3@len < 16384 ->
[<<2:2,Enc3@len:14>>|Enc3@bin];
true ->
encode_fragmented(Enc3@bin, 8)
end
end,
begin
Enc4@element = element(4, Val),
enc_Params(Enc4@element)
end,
align|begin
Enc5@element = element(5, Val),
Enc6@bits = bit_size(Enc5@element),
if Enc6@bits < 128 ->
[Enc6@bits|Enc5@element];
Enc6@bits < 16384 ->
[<<2:2,Enc6@bits:14>>|Enc5@element];
true ->
encode_fragmented(Enc5@element, 1)
end
end].

dec_CryptoToken_cryptoSignedToken_token(Bytes) ->

%% attribute number 1 with type EncodedGeneralToken
{Term1,Bytes1} = dec_EncodedGeneralToken(Bytes),

%% attribute number 2 with type OBJECT IDENTIFIER
{Term2,Bytes2} = begin
V1@Pad3 = bit_size(Bytes1) band 7,
{V1@V0,V1@Buf1} = case Bytes1 of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/binary-unit:8,V1@Buf9/bitstring>> = V1@Buf1,
V1@Conv10 = binary_to_list(V1@V8),
{V1@V11,V1@Buf12}  = {decode_oid(V1@Conv10),V1@Buf9},
{V1@V11,V1@Buf12}
end,

%% attribute number 3 with type Params
{Term3,Bytes3} = dec_Params(Bytes2),

%% attribute number 4 with type BIT STRING
{Term4,Bytes4} = begin
V2@Pad3 = bit_size(Bytes3) band 7,
{V2@V0,V2@Buf1} = case Bytes3 of
<<_:V2@Pad3,0:1,V2@V5:7,V2@V7:V2@V5/binary-unit:1,V2@Buf8/bitstring>> ->
{V2@V7,V2@Buf8};
<<_:V2@Pad3,1:1,0:1,V2@V6:14,V2@V8:V2@V6/binary-unit:1,V2@Buf9/bitstring>> ->
{V2@V8,V2@Buf9};
<<_:V2@Pad3,1:1,1:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V8,V2@Buf9}  = decode_fragmented(V2@V6, V2@Buf7, 1),
{V2@V8,V2@Buf9}
end,
{V2@V10,V2@Buf11}  = {list_to_bitstring([V2@V0]),V2@Buf1},
{V2@V10,V2@Buf11}
end,
{{'CryptoToken_cryptoSignedToken_token',Term1,Term2,Term3,Term4},Bytes4}.


dec_CryptoToken_cryptoSignedToken(Bytes) ->

%% attribute number 1 with type OBJECT IDENTIFIER
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/binary-unit:8,V1@Buf9/bitstring>> = V1@Buf1,
V1@Conv10 = binary_to_list(V1@V8),
{V1@V11,V1@Buf12}  = {decode_oid(V1@Conv10),V1@Buf9},
{V1@V11,V1@Buf12}
end,

%% attribute number 2 with type SEQUENCE
{Term2,Bytes2} = 'dec_CryptoToken_cryptoSignedToken_token'(Bytes1),
{{'CryptoToken_cryptoSignedToken',Term1,Term2},Bytes2}.

'enc_CryptoToken_cryptoHashedToken'(Val) ->
[align,
begin
Enc1@element = element(2, Val),
Enc2@bin = encode_oid(Enc1@element),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end,
begin
Enc3@element = element(3, Val),
enc_ClearToken(Enc3@element)
end|begin
Enc4@element = element(4, Val),
enc_CryptoToken_cryptoHashedToken_token(Enc4@element)
end].
'enc_CryptoToken_cryptoHashedToken_token'(Val) ->
[align,
begin
Enc1@element = element(2, Val),
Enc2@bin = encode_oid(Enc1@element),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end,
begin
Enc3@element = element(3, Val),
enc_Params(Enc3@element)
end,
align|begin
Enc4@element = element(4, Val),
Enc5@bits = bit_size(Enc4@element),
if Enc5@bits < 128 ->
[Enc5@bits|Enc4@element];
Enc5@bits < 16384 ->
[<<2:2,Enc5@bits:14>>|Enc4@element];
true ->
encode_fragmented(Enc4@element, 1)
end
end].

dec_CryptoToken_cryptoHashedToken_token(Bytes) ->

%% attribute number 1 with type OBJECT IDENTIFIER
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/binary-unit:8,V1@Buf9/bitstring>> = V1@Buf1,
V1@Conv10 = binary_to_list(V1@V8),
{V1@V11,V1@Buf12}  = {decode_oid(V1@Conv10),V1@Buf9},
{V1@V11,V1@Buf12}
end,

%% attribute number 2 with type Params
{Term2,Bytes2} = dec_Params(Bytes1),

%% attribute number 3 with type BIT STRING
{Term3,Bytes3} = begin
V2@Pad3 = bit_size(Bytes2) band 7,
{V2@V0,V2@Buf1} = case Bytes2 of
<<_:V2@Pad3,0:1,V2@V5:7,V2@V7:V2@V5/binary-unit:1,V2@Buf8/bitstring>> ->
{V2@V7,V2@Buf8};
<<_:V2@Pad3,1:1,0:1,V2@V6:14,V2@V8:V2@V6/binary-unit:1,V2@Buf9/bitstring>> ->
{V2@V8,V2@Buf9};
<<_:V2@Pad3,1:1,1:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V8,V2@Buf9}  = decode_fragmented(V2@V6, V2@Buf7, 1),
{V2@V8,V2@Buf9}
end,
{V2@V10,V2@Buf11}  = {list_to_bitstring([V2@V0]),V2@Buf1},
{V2@V10,V2@Buf11}
end,
{{'CryptoToken_cryptoHashedToken_token',Term1,Term2,Term3},Bytes3}.


dec_CryptoToken_cryptoHashedToken(Bytes) ->

%% attribute number 1 with type OBJECT IDENTIFIER
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/binary-unit:8,V1@Buf9/bitstring>> = V1@Buf1,
V1@Conv10 = binary_to_list(V1@V8),
{V1@V11,V1@Buf12}  = {decode_oid(V1@Conv10),V1@Buf9},
{V1@V11,V1@Buf12}
end,

%% attribute number 2 with type ClearToken
{Term2,Bytes2} = dec_ClearToken(Bytes1),

%% attribute number 3 with type SEQUENCE
{Term3,Bytes3} = 'dec_CryptoToken_cryptoHashedToken_token'(Bytes2),
{{'CryptoToken_cryptoHashedToken',Term1,Term2,Term3},Bytes3}.

'enc_CryptoToken_cryptoPwdEncr'(Val) ->
[align,
begin
Enc1@element = element(2, Val),
Enc2@bin = encode_oid(Enc1@element),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end,
begin
Enc3@element = element(3, Val),
enc_Params(Enc3@element)
end,
align|begin
Enc4@element = element(4, Val),
Enc5@len = byte_size(Enc4@element),
if Enc5@len < 128 ->
[Enc5@len|Enc4@element];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc4@element];
true ->
encode_fragmented(Enc4@element, 8)
end
end].

dec_CryptoToken_cryptoPwdEncr(Bytes) ->

%% attribute number 1 with type OBJECT IDENTIFIER
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/binary-unit:8,V1@Buf9/bitstring>> = V1@Buf1,
V1@Conv10 = binary_to_list(V1@V8),
{V1@V11,V1@Buf12}  = {decode_oid(V1@Conv10),V1@Buf9},
{V1@V11,V1@Buf12}
end,

%% attribute number 2 with type Params
{Term2,Bytes2} = dec_Params(Bytes1),

%% attribute number 3 with type OCTET STRING
{Term3,Bytes3} = begin
V2@Pad3 = bit_size(Bytes2) band 7,
{V2@V0,V2@Buf1} = case Bytes2 of
<<_:V2@Pad3,0:1,V2@V5:7,V2@V7:V2@V5/binary-unit:8,V2@Buf8/bitstring>> ->
{V2@V7,V2@Buf8};
<<_:V2@Pad3,1:1,0:1,V2@V6:14,V2@V8:V2@V6/binary-unit:8,V2@Buf9/bitstring>> ->
{V2@V8,V2@Buf9};
<<_:V2@Pad3,1:1,1:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V8,V2@Buf9}  = decode_fragmented(V2@V6, V2@Buf7, 8),
{V2@V8,V2@Buf9}
end,
V2@Conv10 = binary:copy(V2@V0),
{V2@Conv10,V2@Buf1}
end,
{{'CryptoToken_cryptoPwdEncr',Term1,Term2,Term3},Bytes3}.



dec_CryptoToken(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:2/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
'dec_CryptoToken_cryptoEncryptedToken'(Bytes2)
end,
{{cryptoEncryptedToken,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
'dec_CryptoToken_cryptoSignedToken'(Bytes2)
end,
{{cryptoSignedToken,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
'dec_CryptoToken_cryptoHashedToken'(Bytes2)
end,
{{cryptoHashedToken,Val},NewBytes};
3 ->
{Val,NewBytes} = begin
'dec_CryptoToken_cryptoPwdEncr'(Bytes2)
end,
{{cryptoPwdEncr,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
V1@Pad6 = bit_size(V1@Buf2) band 7,
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<_:V1@Pad6,0:1,V1@V8:7,V1@Buf9/bitstring>> when V1@V8 =/= 0 ->
{V1@V8,V1@Buf9};
<<_:V1@Pad6,1:1,0:1,V1@V9:14,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10}
end,
<<V1@V11:V1@V3/unit:8,V1@Buf12/bitstring>> = V1@Buf4,
{V1@V11,V1@Buf12}
end,
{V1@V0,V1@Buf1}
end,
begin
V2@Pad3 = bit_size(Bytes2) band 7,
{V2@V0,V2@Buf1} = case Bytes2 of
<<_:V2@Pad3,0:1,V2@V5:7,V2@V7:V2@V5/binary-unit:8,V2@Buf8/bitstring>> ->
{V2@V7,V2@Buf8};
<<_:V2@Pad3,1:1,0:1,V2@V6:14,V2@V8:V2@V6/binary-unit:8,V2@Buf9/bitstring>> ->
{V2@V8,V2@Buf9};
<<_:V2@Pad3,1:1,1:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V8,V2@Buf9}  = decode_fragmented(V2@V6, V2@Buf7, 8),
{V2@V8,V2@Buf9}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
'enc_H235Key'(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= secureChannel ->
begin
Enc2@bits = bit_size(ChoiceVal),
Enc2@bits@sub = Enc2@bits - 1,
if Enc2@bits@sub bsr 11 =:= 0 ->
[<<0:1,0:2>>,
align,
<<Enc2@bits@sub:16>>|ChoiceVal]
end
end;
ChoiceTag =:= sharedSecret ->
[<<0:1,1:2>>|enc_H235Key_sharedSecret(ChoiceVal)];
ChoiceTag =:= certProtectedKey ->
[<<0:1,2:2>>|enc_H235Key_certProtectedKey(ChoiceVal)]
end.
'enc_H235Key_sharedSecret'(Val) ->
[align,
begin
Enc1@element = element(2, Val),
Enc2@bin = encode_oid(Enc1@element),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end,
begin
Enc3@element = element(3, Val),
enc_Params(Enc3@element)
end,
align|begin
Enc4@element = element(4, Val),
Enc5@len = byte_size(Enc4@element),
if Enc5@len < 128 ->
[Enc5@len|Enc4@element];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc4@element];
true ->
encode_fragmented(Enc4@element, 8)
end
end].

dec_H235Key_sharedSecret(Bytes) ->

%% attribute number 1 with type OBJECT IDENTIFIER
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/binary-unit:8,V1@Buf9/bitstring>> = V1@Buf1,
V1@Conv10 = binary_to_list(V1@V8),
{V1@V11,V1@Buf12}  = {decode_oid(V1@Conv10),V1@Buf9},
{V1@V11,V1@Buf12}
end,

%% attribute number 2 with type Params
{Term2,Bytes2} = dec_Params(Bytes1),

%% attribute number 3 with type OCTET STRING
{Term3,Bytes3} = begin
V2@Pad3 = bit_size(Bytes2) band 7,
{V2@V0,V2@Buf1} = case Bytes2 of
<<_:V2@Pad3,0:1,V2@V5:7,V2@V7:V2@V5/binary-unit:8,V2@Buf8/bitstring>> ->
{V2@V7,V2@Buf8};
<<_:V2@Pad3,1:1,0:1,V2@V6:14,V2@V8:V2@V6/binary-unit:8,V2@Buf9/bitstring>> ->
{V2@V8,V2@Buf9};
<<_:V2@Pad3,1:1,1:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V8,V2@Buf9}  = decode_fragmented(V2@V6, V2@Buf7, 8),
{V2@V8,V2@Buf9}
end,
V2@Conv10 = binary:copy(V2@V0),
{V2@Conv10,V2@Buf1}
end,
{{'H235Key_sharedSecret',Term1,Term2,Term3},Bytes3}.

'enc_H235Key_certProtectedKey'(Val) ->
[begin
Enc1@element = element(2, Val),
enc_EncodedKeySignedMaterial(Enc1@element)
end,
align,
begin
Enc2@element = element(3, Val),
Enc3@bin = encode_oid(Enc2@element),
Enc3@len = byte_size(Enc3@bin),
if Enc3@len < 128 ->
[Enc3@len|Enc3@bin];
Enc3@len < 16384 ->
[<<2:2,Enc3@len:14>>|Enc3@bin];
true ->
encode_fragmented(Enc3@bin, 8)
end
end,
begin
Enc4@element = element(4, Val),
enc_Params(Enc4@element)
end,
align|begin
Enc5@element = element(5, Val),
Enc6@bits = bit_size(Enc5@element),
if Enc6@bits < 128 ->
[Enc6@bits|Enc5@element];
Enc6@bits < 16384 ->
[<<2:2,Enc6@bits:14>>|Enc5@element];
true ->
encode_fragmented(Enc5@element, 1)
end
end].

dec_H235Key_certProtectedKey(Bytes) ->

%% attribute number 1 with type EncodedKeySignedMaterial
{Term1,Bytes1} = dec_EncodedKeySignedMaterial(Bytes),

%% attribute number 2 with type OBJECT IDENTIFIER
{Term2,Bytes2} = begin
V1@Pad3 = bit_size(Bytes1) band 7,
{V1@V0,V1@Buf1} = case Bytes1 of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/binary-unit:8,V1@Buf9/bitstring>> = V1@Buf1,
V1@Conv10 = binary_to_list(V1@V8),
{V1@V11,V1@Buf12}  = {decode_oid(V1@Conv10),V1@Buf9},
{V1@V11,V1@Buf12}
end,

%% attribute number 3 with type Params
{Term3,Bytes3} = dec_Params(Bytes2),

%% attribute number 4 with type BIT STRING
{Term4,Bytes4} = begin
V2@Pad3 = bit_size(Bytes3) band 7,
{V2@V0,V2@Buf1} = case Bytes3 of
<<_:V2@Pad3,0:1,V2@V5:7,V2@V7:V2@V5/binary-unit:1,V2@Buf8/bitstring>> ->
{V2@V7,V2@Buf8};
<<_:V2@Pad3,1:1,0:1,V2@V6:14,V2@V8:V2@V6/binary-unit:1,V2@Buf9/bitstring>> ->
{V2@V8,V2@Buf9};
<<_:V2@Pad3,1:1,1:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V8,V2@Buf9}  = decode_fragmented(V2@V6, V2@Buf7, 1),
{V2@V8,V2@Buf9}
end,
{V2@V10,V2@Buf11}  = {list_to_bitstring([V2@V0]),V2@Buf1},
{V2@V10,V2@Buf11}
end,
{{'H235Key_certProtectedKey',Term1,Term2,Term3,Term4},Bytes4}.



dec_H235Key(Bytes) ->
case Bytes of
<<0:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
<<V1@V0:2/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes1,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
begin
V2@Pad2 = bit_size(Bytes2) band 7,
<<_:V2@Pad2,V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes2,
V2@Add4 = V2@V0 + 1,
<<V2@V5:V2@Add4/binary-unit:1,V2@Buf6/bitstring>> = V2@Buf1,
{V2@V7,V2@Buf8}  = {list_to_bitstring([V2@V5]),V2@Buf6},
{V2@V7,V2@Buf8}
end
end,
{{secureChannel,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
'dec_H235Key_sharedSecret'(Bytes2)
end,
{{sharedSecret,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
'dec_H235Key_certProtectedKey'(Bytes2)
end,
{{certProtectedKey,Val},NewBytes}
end;

<<1:1,Bytes1/bitstring>> ->
{Choice,Bytes2} = 
begin
{V1@V0,V1@Buf1} = case Bytes1 of
<<0:1,V1@V3:6,V1@Buf4/bitstring>> ->
{V1@V3,V1@Buf4};
<<1:1,V1@Buf2/bitstring>> ->
V1@Pad6 = bit_size(V1@Buf2) band 7,
{V1@V3,V1@Buf4} = case V1@Buf2 of
<<_:V1@Pad6,0:1,V1@V8:7,V1@Buf9/bitstring>> when V1@V8 =/= 0 ->
{V1@V8,V1@Buf9};
<<_:V1@Pad6,1:1,0:1,V1@V9:14,V1@Buf10/bitstring>> when V1@V9 =/= 0 ->
{V1@V9,V1@Buf10}
end,
<<V1@V11:V1@V3/unit:8,V1@Buf12/bitstring>> = V1@Buf4,
{V1@V11,V1@Buf12}
end,
{V1@V0,V1@Buf1}
end,
begin
V2@Pad3 = bit_size(Bytes2) band 7,
{V2@V0,V2@Buf1} = case Bytes2 of
<<_:V2@Pad3,0:1,V2@V5:7,V2@V7:V2@V5/binary-unit:8,V2@Buf8/bitstring>> ->
{V2@V7,V2@Buf8};
<<_:V2@Pad3,1:1,0:1,V2@V6:14,V2@V8:V2@V6/binary-unit:8,V2@Buf9/bitstring>> ->
{V2@V8,V2@Buf9};
<<_:V2@Pad3,1:1,1:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V8,V2@Buf9}  = decode_fragmented(V2@V6, V2@Buf7, 8),
{V2@V8,V2@Buf9}
end
end,
case Choice of
_ ->
{{asn1_ExtAlt,V2@V0},V2@Buf1}
end
end.
'enc_KeySignedMaterial'(Val) ->
[begin
Enc1@element = element(4, Val),
Enc2@element = element(5, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc3@element = element(2, Val),
Enc4@len = length(Enc3@element),
Enc4@bin = encode_chars_16bit(Enc3@element),
Enc4@len@sub = Enc4@len - 1,
if Enc4@len@sub bsr 7 =:= 0 ->
[<<Enc4@len@sub:7>>,
align|Enc4@bin]
end
end,
begin
Enc5@element = element(3, Val),
encode_unconstrained_number(Enc5@element)
end,
begin
Enc7@element = element(4, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
true ->
encode_unconstrained_number(Enc7@element)
end
end,
begin
Enc10@element = element(5, Val),
if Enc10@element =:= asn1_NOVALUE ->
[];
true ->
begin
Enc10@element@sub = Enc10@element - 1,
if 0 =< Enc10@element@sub, Enc10@element@sub < 4294967295 ->
begin
Enc10@element@sub@bin = binary:encode_unsigned(Enc10@element@sub),
Enc10@element@sub@bin_size0 = byte_size(Enc10@element@sub@bin),
Enc10@element@sub@bin_size = Enc10@element@sub@bin_size0 - 1,
[<<Enc10@element@sub@bin_size:2,0:6>>|Enc10@element@sub@bin]
end;
true ->
exit({error,{asn1,{illegal_value,Enc10@element}}})
end
end
end
end|begin
Enc13@element = element(6, Val),
enc_KeySignedMaterial_encrptval(Enc13@element)
end].
'enc_KeySignedMaterial_encrptval'(Val) ->
[align,
begin
Enc1@element = element(2, Val),
Enc2@bin = encode_oid(Enc1@element),
Enc2@len = byte_size(Enc2@bin),
if Enc2@len < 128 ->
[Enc2@len|Enc2@bin];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc2@bin];
true ->
encode_fragmented(Enc2@bin, 8)
end
end,
begin
Enc3@element = element(3, Val),
enc_Params(Enc3@element)
end,
align|begin
Enc4@element = element(4, Val),
Enc5@len = byte_size(Enc4@element),
if Enc5@len < 128 ->
[Enc5@len|Enc4@element];
Enc5@len < 16384 ->
[<<2:2,Enc5@len:14>>|Enc4@element];
true ->
encode_fragmented(Enc4@element, 8)
end
end].

dec_KeySignedMaterial_encrptval(Bytes) ->

%% attribute number 1 with type OBJECT IDENTIFIER
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/binary-unit:8,V1@Buf9/bitstring>> = V1@Buf1,
V1@Conv10 = binary_to_list(V1@V8),
{V1@V11,V1@Buf12}  = {decode_oid(V1@Conv10),V1@Buf9},
{V1@V11,V1@Buf12}
end,

%% attribute number 2 with type Params
{Term2,Bytes2} = dec_Params(Bytes1),

%% attribute number 3 with type OCTET STRING
{Term3,Bytes3} = begin
V2@Pad3 = bit_size(Bytes2) band 7,
{V2@V0,V2@Buf1} = case Bytes2 of
<<_:V2@Pad3,0:1,V2@V5:7,V2@V7:V2@V5/binary-unit:8,V2@Buf8/bitstring>> ->
{V2@V7,V2@Buf8};
<<_:V2@Pad3,1:1,0:1,V2@V6:14,V2@V8:V2@V6/binary-unit:8,V2@Buf9/bitstring>> ->
{V2@V8,V2@Buf9};
<<_:V2@Pad3,1:1,1:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V8,V2@Buf9}  = decode_fragmented(V2@V6, V2@Buf7, 8),
{V2@V8,V2@Buf9}
end,
V2@Conv10 = binary:copy(V2@V0),
{V2@Conv10,V2@Buf1}
end,
{{'KeySignedMaterial_encrptval',Term1,Term2,Term3},Bytes3}.



dec_KeySignedMaterial(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute number 1 with type BMPString
{Term1,Bytes2} = begin
<<V2@V0:7/unsigned-unit:1,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 1,
V2@Pad5 = bit_size(V2@Buf1) band 7,
<<_:V2@Pad5,V2@V3:V2@Add2/binary-unit:16,V2@Buf4/bitstring>> = V2@Buf1,
{V2@V7,V2@Buf8}  = {decode_chars_16bit(V2@V3),V2@Buf4},
{V2@V7,V2@Buf8}
end,

%% attribute number 2 with type INTEGER
{Term2,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:7,V3@Buf4/bitstring>> when V3@V3 =/= 0 ->
{V3@V3,V3@Buf4};
<<1:1,0:1,V3@V4:14,V3@Buf5/bitstring>> when V3@V4 =/= 0 ->
{V3@V4,V3@Buf5}
end,
<<V3@V6:V3@V0/signed-unit:8,V3@Buf7/bitstring>> = V3@Buf1,
{V3@V6,V3@Buf7}
end,

%% attribute number 3 with type INTEGER
{Term3,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
begin
V4@Pad3 = bit_size(Bytes3) band 7,
{V4@V0,V4@Buf1} = case Bytes3 of
<<_:V4@Pad3,0:1,V4@V5:7,V4@Buf6/bitstring>> when V4@V5 =/= 0 ->
{V4@V5,V4@Buf6};
<<_:V4@Pad3,1:1,0:1,V4@V6:14,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7}
end,
<<V4@V8:V4@V0/signed-unit:8,V4@Buf9/bitstring>> = V4@Buf1,
{V4@V8,V4@Buf9}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute number 4 with type INTEGER
{Term4,Bytes5} = case Opt band 1 of
1 ->
begin
<<V5@V0:2/unsigned-unit:1,V5@Buf1/bitstring>> = Bytes4,
V5@Add2 = V5@V0 + 1,
V5@Pad5 = bit_size(V5@Buf1) band 7,
<<_:V5@Pad5,V5@V3:V5@Add2/unsigned-unit:8,V5@Buf4/bitstring>> = V5@Buf1,
V5@Add7 = V5@V3 + 1,
{V5@Add7,V5@Buf4}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute number 5 with type SEQUENCE
{Term5,Bytes6} = 'dec_KeySignedMaterial_encrptval'(Bytes5),
{{'KeySignedMaterial',Term1,Term2,Term3,Term4,Term5},Bytes6}.

'enc_EncodedKeySignedMaterial'(Val) ->
Enc1@output = enc_KeySignedMaterial(Val),
Enc1@bin = complete(Enc1@output),
Enc1@len = byte_size(Enc1@bin),
if Enc1@len < 128 ->
[align,
Enc1@len|Enc1@bin];
Enc1@len < 16384 ->
[align,
<<2:2,Enc1@len:14>>|Enc1@bin];
true ->
[align|encode_fragmented(Enc1@bin, 8)]
end.


dec_EncodedKeySignedMaterial(Bytes) ->
begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@V7:V1@V5/binary-unit:8,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@V8:V1@V6/binary-unit:8,V1@Buf9/bitstring>> ->
{V1@V8,V1@Buf9};
<<_:V1@Pad3,1:1,1:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V8,V1@Buf9}  = decode_fragmented(V1@V6, V1@Buf7, 8),
{V1@V8,V1@Buf9}
end,
{V1@V10,V1@Buf11}  = begin
{Tmpval1,_} = dec_KeySignedMaterial(V1@V0),
{Tmpval1,V1@Buf1}
end,
{V1@V10,V1@Buf11}
end.

'enc_H235CertificateSignature'(Val) ->
[begin
Enc1@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end
end,
begin
Enc3@element = element(2, Val),
enc_TypedCertificate(Enc3@element)
end,
align,
begin
Enc4@element = element(3, Val),
encode_unconstrained_number(Enc4@element)
end,
begin
Enc6@element = element(4, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
true ->
encode_unconstrained_number(Enc6@element)
end
end|begin
Enc9@element = element(5, Val),
enc_H235CertificateSignature_signature(Enc9@element)
end].
'enc_H235CertificateSignature_signature'(Val) ->
[begin
Enc1@element = element(2, Val),
enc_EncodedReturnSig(Enc1@element)
end,
align,
begin
Enc2@element = element(3, Val),
Enc3@bin = encode_oid(Enc2@element),
Enc3@len = byte_size(Enc3@bin),
if Enc3@len < 128 ->
[Enc3@len|Enc3@bin];
Enc3@len < 16384 ->
[<<2:2,Enc3@len:14>>|Enc3@bin];
true ->
encode_fragmented(Enc3@bin, 8)
end
end,
begin
Enc4@element = element(4, Val),
enc_Params(Enc4@element)
end,
align|begin
Enc5@element = element(5, Val),
Enc6@bits = bit_size(Enc5@element),
if Enc6@bits < 128 ->
[Enc6@bits|Enc5@element];
Enc6@bits < 16384 ->
[<<2:2,Enc6@bits:14>>|Enc5@element];
true ->
encode_fragmented(Enc5@element, 1)
end
end].

dec_H235CertificateSignature_signature(Bytes) ->

%% attribute number 1 with type EncodedReturnSig
{Term1,Bytes1} = dec_EncodedReturnSig(Bytes),

%% attribute number 2 with type OBJECT IDENTIFIER
{Term2,Bytes2} = begin
V1@Pad3 = bit_size(Bytes1) band 7,
{V1@V0,V1@Buf1} = case Bytes1 of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/binary-unit:8,V1@Buf9/bitstring>> = V1@Buf1,
V1@Conv10 = binary_to_list(V1@V8),
{V1@V11,V1@Buf12}  = {decode_oid(V1@Conv10),V1@Buf9},
{V1@V11,V1@Buf12}
end,

%% attribute number 3 with type Params
{Term3,Bytes3} = dec_Params(Bytes2),

%% attribute number 4 with type BIT STRING
{Term4,Bytes4} = begin
V2@Pad3 = bit_size(Bytes3) band 7,
{V2@V0,V2@Buf1} = case Bytes3 of
<<_:V2@Pad3,0:1,V2@V5:7,V2@V7:V2@V5/binary-unit:1,V2@Buf8/bitstring>> ->
{V2@V7,V2@Buf8};
<<_:V2@Pad3,1:1,0:1,V2@V6:14,V2@V8:V2@V6/binary-unit:1,V2@Buf9/bitstring>> ->
{V2@V8,V2@Buf9};
<<_:V2@Pad3,1:1,1:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V8,V2@Buf9}  = decode_fragmented(V2@V6, V2@Buf7, 1),
{V2@V8,V2@Buf9}
end,
{V2@V10,V2@Buf11}  = {list_to_bitstring([V2@V0]),V2@Buf1},
{V2@V10,V2@Buf11}
end,
{{'H235CertificateSignature_signature',Term1,Term2,Term3,Term4},Bytes4}.



dec_H235CertificateSignature(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
{Opt,Bytes2} = begin
<<V2@V0:1,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute number 1 with type TypedCertificate
{Term1,Bytes3} = dec_TypedCertificate(Bytes2),

%% attribute number 2 with type INTEGER
{Term2,Bytes4} = begin
V3@Pad3 = bit_size(Bytes3) band 7,
{V3@V0,V3@Buf1} = case Bytes3 of
<<_:V3@Pad3,0:1,V3@V5:7,V3@Buf6/bitstring>> when V3@V5 =/= 0 ->
{V3@V5,V3@Buf6};
<<_:V3@Pad3,1:1,0:1,V3@V6:14,V3@Buf7/bitstring>> when V3@V6 =/= 0 ->
{V3@V6,V3@Buf7}
end,
<<V3@V8:V3@V0/signed-unit:8,V3@Buf9/bitstring>> = V3@Buf1,
{V3@V8,V3@Buf9}
end,

%% attribute number 3 with type INTEGER
{Term3,Bytes5} = case Opt band 1 of
1 ->
begin
V4@Pad3 = bit_size(Bytes4) band 7,
{V4@V0,V4@Buf1} = case Bytes4 of
<<_:V4@Pad3,0:1,V4@V5:7,V4@Buf6/bitstring>> when V4@V5 =/= 0 ->
{V4@V5,V4@Buf6};
<<_:V4@Pad3,1:1,0:1,V4@V6:14,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7}
end,
<<V4@V8:V4@V0/signed-unit:8,V4@Buf9/bitstring>> = V4@Buf1,
{V4@V8,V4@Buf9}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,

%% attribute number 4 with type SEQUENCE
{Term4,Bytes6} = 'dec_H235CertificateSignature_signature'(Bytes5),

%% Extensions
{Extensions,Bytes7} = case Ext of
0 -> {<<>>,Bytes6};
1 ->
{V5@V0,V5@Buf1} = case Bytes6 of
<<0:1,V5@V3:6,V5@Buf4/bitstring>> ->
V5@Add5 = V5@V3 + 1,
{V5@Add5,V5@Buf4};
<<1:1,V5@Buf2/bitstring>> ->
V5@Pad6 = bit_size(V5@Buf2) band 7,
{V5@V3,V5@Buf4} = case V5@Buf2 of
<<_:V5@Pad6,0:1,V5@V8:7,V5@Buf9/bitstring>> when V5@V8 =/= 0 ->
{V5@V8,V5@Buf9};
<<_:V5@Pad6,1:1,0:1,V5@V9:14,V5@Buf10/bitstring>> when V5@V9 =/= 0 ->
{V5@V9,V5@Buf10}
end,
{V5@V3,V5@Buf4}
end,
<<V5@V11:V5@V0/bitstring-unit:1,V5@Buf12/bitstring>> = V5@Buf1,
{V5@V11,V5@Buf12}
end,
Bytes8= skipextensions(Bytes7, 1, Extensions),
{{'H235CertificateSignature',Term1,Term2,Term3,Term4},Bytes8}.

'enc_ReturnSig'(Val) ->
[begin
Enc1@element = element(4, Val),
Enc2@element = element(5, Val),
if Enc1@element =:= asn1_NOVALUE ->
if Enc2@element =:= asn1_NOVALUE ->
<<0:1,0:1>>;
true ->
<<0:1,1:1>>
end;
true ->
if Enc2@element =:= asn1_NOVALUE ->
<<1:1,0:1>>;
true ->
<<1:1,1:1>>
end
end
end,
begin
Enc3@element = element(2, Val),
Enc4@len = length(Enc3@element),
Enc4@bin = encode_chars_16bit(Enc3@element),
Enc4@len@sub = Enc4@len - 1,
if Enc4@len@sub bsr 7 =:= 0 ->
[<<Enc4@len@sub:7>>,
align|Enc4@bin]
end
end,
begin
Enc5@element = element(3, Val),
encode_unconstrained_number(Enc5@element)
end,
begin
Enc7@element = element(4, Val),
if Enc7@element =:= asn1_NOVALUE ->
[];
true ->
encode_unconstrained_number(Enc7@element)
end
end|begin
Enc10@element = element(5, Val),
if Enc10@element =:= asn1_NOVALUE ->
[];
true ->
enc_TypedCertificate(Enc10@element)
end
end].


dec_ReturnSig(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:2,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute number 1 with type BMPString
{Term1,Bytes2} = begin
<<V2@V0:7/unsigned-unit:1,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 1,
V2@Pad5 = bit_size(V2@Buf1) band 7,
<<_:V2@Pad5,V2@V3:V2@Add2/binary-unit:16,V2@Buf4/bitstring>> = V2@Buf1,
{V2@V7,V2@Buf8}  = {decode_chars_16bit(V2@V3),V2@Buf4},
{V2@V7,V2@Buf8}
end,

%% attribute number 2 with type INTEGER
{Term2,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:7,V3@Buf4/bitstring>> when V3@V3 =/= 0 ->
{V3@V3,V3@Buf4};
<<1:1,0:1,V3@V4:14,V3@Buf5/bitstring>> when V3@V4 =/= 0 ->
{V3@V4,V3@Buf5}
end,
<<V3@V6:V3@V0/signed-unit:8,V3@Buf7/bitstring>> = V3@Buf1,
{V3@V6,V3@Buf7}
end,

%% attribute number 3 with type INTEGER
{Term3,Bytes4} = case (Opt bsr 1) band 1 of
1 ->
begin
V4@Pad3 = bit_size(Bytes3) band 7,
{V4@V0,V4@Buf1} = case Bytes3 of
<<_:V4@Pad3,0:1,V4@V5:7,V4@Buf6/bitstring>> when V4@V5 =/= 0 ->
{V4@V5,V4@Buf6};
<<_:V4@Pad3,1:1,0:1,V4@V6:14,V4@Buf7/bitstring>> when V4@V6 =/= 0 ->
{V4@V6,V4@Buf7}
end,
<<V4@V8:V4@V0/signed-unit:8,V4@Buf9/bitstring>> = V4@Buf1,
{V4@V8,V4@Buf9}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,

%% attribute number 4 with type TypedCertificate
{Term4,Bytes5} = case Opt band 1 of
1 ->
dec_TypedCertificate(Bytes4);
0 ->
{asn1_NOVALUE,Bytes4}
end,
{{'ReturnSig',Term1,Term2,Term3,Term4},Bytes5}.

'enc_EncodedReturnSig'(Val) ->
Enc1@output = enc_ReturnSig(Val),
Enc1@bin = complete(Enc1@output),
Enc1@len = byte_size(Enc1@bin),
if Enc1@len < 128 ->
[align,
Enc1@len|Enc1@bin];
Enc1@len < 16384 ->
[align,
<<2:2,Enc1@len:14>>|Enc1@bin];
true ->
[align|encode_fragmented(Enc1@bin, 8)]
end.


dec_EncodedReturnSig(Bytes) ->
begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@V7:V1@V5/binary-unit:8,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@V8:V1@V6/binary-unit:8,V1@Buf9/bitstring>> ->
{V1@V8,V1@Buf9};
<<_:V1@Pad3,1:1,1:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V8,V1@Buf9}  = decode_fragmented(V1@V6, V1@Buf7, 8),
{V1@V8,V1@Buf9}
end,
{V1@V10,V1@Buf11}  = begin
{Tmpval1,_} = dec_ReturnSig(V1@V0),
{Tmpval1,V1@Buf1}
end,
{V1@V10,V1@Buf11}
end.

'enc_KeySyncMaterial'(Val) ->
[begin
Enc2@element = element(2, Val),
Enc3@len = length(Enc2@element),
Enc3@bin = encode_chars_16bit(Enc2@element),
Enc3@len@sub = Enc3@len - 1,
if Enc3@len@sub bsr 7 =:= 0 ->
[<<0:1,Enc3@len@sub:7>>,
align|Enc3@bin]
end
end|begin
Enc4@element = element(3, Val),
Enc5@bits = bit_size(Enc4@element),
Enc5@bits@sub = Enc5@bits - 1,
if Enc5@bits@sub bsr 11 =:= 0 ->
[<<Enc5@bits@sub:16>>|Enc4@element]
end
end].


dec_KeySyncMaterial(Bytes) ->
{Ext,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute number 1 with type BMPString
{Term1,Bytes2} = begin
<<V2@V0:7/unsigned-unit:1,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 1,
V2@Pad5 = bit_size(V2@Buf1) band 7,
<<_:V2@Pad5,V2@V3:V2@Add2/binary-unit:16,V2@Buf4/bitstring>> = V2@Buf1,
{V2@V7,V2@Buf8}  = {decode_chars_16bit(V2@V3),V2@Buf4},
{V2@V7,V2@Buf8}
end,

%% attribute number 2 with type BIT STRING
{Term2,Bytes3} = begin
<<V3@V0:2/unsigned-unit:8,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
<<V3@V3:V3@Add2/binary-unit:1,V3@Buf4/bitstring>> = V3@Buf1,
{V3@V5,V3@Buf6}  = {list_to_bitstring([V3@V3]),V3@Buf4},
{V3@V5,V3@Buf6}
end,

%% Extensions
{Extensions,Bytes4} = case Ext of
0 -> {<<>>,Bytes3};
1 ->
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:6,V4@Buf4/bitstring>> ->
V4@Add5 = V4@V3 + 1,
{V4@Add5,V4@Buf4};
<<1:1,V4@Buf2/bitstring>> ->
V4@Pad6 = bit_size(V4@Buf2) band 7,
{V4@V3,V4@Buf4} = case V4@Buf2 of
<<_:V4@Pad6,0:1,V4@V8:7,V4@Buf9/bitstring>> when V4@V8 =/= 0 ->
{V4@V8,V4@Buf9};
<<_:V4@Pad6,1:1,0:1,V4@V9:14,V4@Buf10/bitstring>> when V4@V9 =/= 0 ->
{V4@V9,V4@Buf10}
end,
{V4@V3,V4@Buf4}
end,
<<V4@V11:V4@V0/bitstring-unit:1,V4@Buf12/bitstring>> = V4@Buf1,
{V4@V11,V4@Buf12}
end,
Bytes5= skipextensions(Bytes4, 1, Extensions),
{{'KeySyncMaterial',Term1,Term2},Bytes5}.

'enc_EncodedKeySyncMaterial'(Val) ->
Enc1@output = enc_KeySyncMaterial(Val),
Enc1@bin = complete(Enc1@output),
Enc1@len = byte_size(Enc1@bin),
if Enc1@len < 128 ->
[align,
Enc1@len|Enc1@bin];
Enc1@len < 16384 ->
[align,
<<2:2,Enc1@len:14>>|Enc1@bin];
true ->
[align|encode_fragmented(Enc1@bin, 8)]
end.


dec_EncodedKeySyncMaterial(Bytes) ->
begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@V7:V1@V5/binary-unit:8,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@V8:V1@V6/binary-unit:8,V1@Buf9/bitstring>> ->
{V1@V8,V1@Buf9};
<<_:V1@Pad3,1:1,1:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V8,V1@Buf9}  = decode_fragmented(V1@V6, V1@Buf7, 8),
{V1@V8,V1@Buf9}
end,
{V1@V10,V1@Buf11}  = begin
{Tmpval1,_} = dec_KeySyncMaterial(V1@V0),
{Tmpval1,V1@Buf1}
end,
{V1@V10,V1@Buf11}
end.


%%%
%%% Run-time functions.
%%%

align(Bin) when is_binary(Bin) ->
    Bin;
align(BitStr) when is_bitstring(BitStr) ->
    AlignBits = bit_size(BitStr) rem 8,
    <<_:AlignBits,Rest/binary>> = BitStr,
    Rest.

complete(L0) ->
    L = complete(L0, []),
    case list_to_bitstring(L) of
        <<>> ->
            <<0>>;
        Bin ->
            Bin
    end.

complete([], Bits, []) ->
    case Bits band 7 of
        0 ->
            [];
        N ->
            [<<0:(8 - N)>>]
    end;
complete([], Bits, [H|More]) ->
    complete(H, Bits, More);
complete([align|T], Bits, More) ->
    case Bits band 7 of
        0 ->
            complete(T, More);
        1 ->
            [<<0:7>>|complete(T, More)];
        2 ->
            [<<0:6>>|complete(T, More)];
        3 ->
            [<<0:5>>|complete(T, More)];
        4 ->
            [<<0:4>>|complete(T, More)];
        5 ->
            [<<0:3>>|complete(T, More)];
        6 ->
            [<<0:2>>|complete(T, More)];
        7 ->
            [<<0:1>>|complete(T, More)]
    end;
complete([[]|T], Bits, More) ->
    complete(T, Bits, More);
complete([[_|_] = H], Bits, More) ->
    complete(H, Bits, More);
complete([[_|_] = H|T], Bits, More) ->
    complete(H, Bits, [T|More]);
complete([H|T], Bits, More) when is_integer(H); is_binary(H) ->
    [H|complete(T, Bits, More)];
complete([H|T], Bits, More) ->
    [H|complete(T, Bits + bit_size(H), More)];
complete(Bin, Bits, More) when is_binary(Bin) ->
    [Bin|complete([], Bits, More)];
complete(Bin, Bits, More) ->
    [Bin|complete([], Bits + bit_size(Bin), More)].

complete([], []) ->
    [];
complete([], [H|More]) ->
    complete(H, More);
complete([align|T], More) ->
    complete(T, More);
complete([[]|T], More) ->
    complete(T, More);
complete([[_|_] = H], More) ->
    complete(H, More);
complete([[_|_] = H|T], More) ->
    complete(H, [T|More]);
complete([H|T], More) when is_integer(H); is_binary(H) ->
    [H|complete(T, More)];
complete([H|T], More) ->
    [H|complete(T, bit_size(H), More)];
complete(Bin, More) when is_binary(Bin) ->
    [Bin|complete([], More)];
complete(Bin, More) ->
    [Bin|complete([], bit_size(Bin), More)].

dec_subidentifiers([H|T], Av, Al) when H >= 128 ->
    dec_subidentifiers(T, Av bsl 7 bor H band 127, Al);
dec_subidentifiers([H|T], Av, Al) ->
    dec_subidentifiers(T, 0, [Av bsl 7 bor H|Al]);
dec_subidentifiers([], _Av, Al) ->
    lists:reverse(Al).

decode_chars_16bit(Val) ->
    Cs =
        [ 
         C ||
             <<C:16>> <= Val
        ],
    decode_chars_16bit_1(Cs).

decode_chars_16bit_1([H|T]) when H < 256 ->
    [H|decode_chars_16bit_1(T)];
decode_chars_16bit_1([H|T]) ->
    [{0,0,H bsr 8,H band 255}|decode_chars_16bit_1(T)];
decode_chars_16bit_1([]) ->
    [].

decode_fragmented(SegSz0, Buf0, Unit) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Res:SegSz/bitstring,Buf/bitstring>> = Buf0,
    decode_fragmented_1(Buf, Unit, Res).

decode_fragmented_1(<<0:1,N:7,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>,Buf};
decode_fragmented_1(<<1:1,0:1,N:14,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>,Buf};
decode_fragmented_1(<<1:1,1:1,SegSz0:6,Buf0/bitstring>>, Unit, Res0) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Frag:SegSz/bitstring,Buf/bitstring>> = Buf0,
    Res = <<Res0/bitstring,Frag/bitstring>>,
    decode_fragmented_1(Buf, Unit, Res).

decode_length(Buffer) ->
    case align(Buffer) of
        <<0:1,Oct:7,Rest/binary>> ->
            {Oct,Rest};
        <<2:2,Val:14,Rest/binary>> ->
            {Val,Rest};
        <<3:2,_Val:14,_Rest/binary>> ->
            exit({error,{asn1,{decode_length,{nyi,above_16k}}}})
    end.

decode_oid(Octets) ->
    [First|Rest] = dec_subidentifiers(Octets, 0, []),
    Idlist =
        if
            First < 40 ->
                [0,First|Rest];
            First < 80 ->
                [1,First - 40|Rest];
            true ->
                [2,First - 80|Rest]
        end,
    list_to_tuple(Idlist).

e_o_e(Num) when Num < 128 ->
    Num bor 128;
e_o_e(Num) ->
    [e_o_e(Num bsr 7),Num band 127 bor 128].

e_object_element(Num) when Num < 128 ->
    [Num];
e_object_element(Num) ->
    [e_o_e(Num bsr 7),Num band 127].

e_object_elements([], Acc) ->
    lists:reverse(Acc);
e_object_elements([H|T], Acc) ->
    e_object_elements(T, [e_object_element(H)|Acc]).

e_object_identifier([E1,E2|Tail])
    when E1 >= 0, E1 < 2, E2 < 40; E1 =:= 2 ->
    Head = 40 * E1 + E2,
    e_object_elements([Head|Tail], []);
e_object_identifier([_,_|_Tail] = Oid) ->
    exit({error,{asn1,{illegal_value,Oid}}}).

encode_chars_16bit(Val) ->
    L = [ 
         case C of
             {0,0,A,B} ->
                 [A,B];
             C when is_integer(C) ->
                 [0,C]
         end ||
             C <- Val
        ],
    iolist_to_binary(L).

encode_fragmented(Bin, Unit) ->
    encode_fragmented_1(Bin, Unit, 4).

encode_fragmented_1(Bin, Unit, N) ->
    SegSz = Unit * N * 16384,
    case Bin of
        <<B:SegSz/bitstring,T/bitstring>> ->
            [<<3:2,N:6>>,B|encode_fragmented_1(T, Unit, N)];
        _ when N > 1 ->
            encode_fragmented_1(Bin, Unit, N - 1);
        _ ->
            case bit_size(Bin) div Unit of
                Len when Len < 128 ->
                    [Len,Bin];
                Len when Len < 16384 ->
                    [<<2:2,Len:14>>,Bin]
            end
    end.

encode_oid(Val) when is_tuple(Val) ->
    encode_oid(tuple_to_list(Val));
encode_oid(Val) ->
    iolist_to_binary(e_object_identifier(Val)).

encode_unconstrained_number(Val) when Val >= 0 ->
    if
        Val < 128 ->
            [1,Val];
        Val < 256 ->
            [<<2,0>>,Val];
        true ->
            case binary:encode_unsigned(Val) of
                <<0:1,_/bitstring>> = Bin ->
                    case byte_size(Bin) of
                        Sz when Sz < 128 ->
                            [Sz,Bin];
                        Sz when Sz < 16384 ->
                            [<<2:2,Sz:14>>,Bin]
                    end;
                <<1:1,_/bitstring>> = Bin ->
                    case byte_size(Bin) + 1 of
                        Sz when Sz < 128 ->
                            [Sz,0,Bin];
                        Sz when Sz < 16384 ->
                            [<<2:2,Sz:14,0:8>>,Bin]
                    end
            end
    end;
encode_unconstrained_number(Val) ->
    Oct = enint(Val, []),
    Len = length(Oct),
    if
        Len < 128 ->
            [Len|Oct];
        Len < 16384 ->
            [<<2:2,Len:14>>|Oct]
    end.

enint(- 1, [B1|T]) when B1 > 127 ->
    [B1|T];
enint(N, Acc) ->
    enint(N bsr 8, [N band 255|Acc]).

extension_bitmap(Val, Pos, Limit) ->
    extension_bitmap(Val, Pos, Limit, 0).

extension_bitmap(_Val, Pos, Limit, Acc) when Pos >= Limit ->
    Acc;
extension_bitmap(Val, Pos, Limit, Acc) ->
    Bit =
        case element(Pos, Val) of
            asn1_NOVALUE ->
                0;
            _ ->
                1
        end,
    extension_bitmap(Val, Pos + 1, Limit, Acc bsl 1 bor Bit).

skipextensions(Bytes0, Nr, ExtensionBitstr)
    when is_bitstring(ExtensionBitstr) ->
    Prev = Nr - 1,
    case ExtensionBitstr of
        <<_:Prev,1:1,_/bitstring>> ->
            {Len,Bytes1} = decode_length(Bytes0),
            <<_:Len/binary,Bytes2/bitstring>> = Bytes1,
            skipextensions(Bytes2, Nr + 1, ExtensionBitstr);
        <<_:Prev,0:1,_/bitstring>> ->
            skipextensions(Bytes0, Nr + 1, ExtensionBitstr);
        _ ->
            Bytes0
    end.
